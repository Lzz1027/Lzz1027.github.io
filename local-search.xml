<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>查漏补缺-本地缓存与HTTP缓存</title>
    <link href="/2024/09/06/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-Http%E7%BC%93%E5%AD%98/"/>
    <url>/2024/09/06/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-Http%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是缓存？为什么要缓存？"><a href="#什么是缓存？为什么要缓存？" class="headerlink" title="什么是缓存？为什么要缓存？"></a>什么是缓存？为什么要缓存？</h1><p>缓存是指<strong>将之前获取的资源或者文件暂存</strong>，以便下次访问时重复使用，由于不需要重新获取完整文件，可以<strong>节省带宽资源并提升访问速度</strong></p><h2 id="根据什么判断是否需要缓存"><a href="#根据什么判断是否需要缓存" class="headerlink" title="根据什么判断是否需要缓存"></a>根据什么判断是否需要缓存</h2><h3 id="一、系统访问频率"><a href="#一、系统访问频率" class="headerlink" title="一、系统访问频率"></a>一、系统访问频率</h3><p><strong>1.当系统的访问频率较高时,使用缓存可以提高数据的读取速度。</strong></p><p>例如,在一个电商网站中,商品列表是用户经常访问的内容之一。如果每次访问商品列表都要从数据库中读取数据,将会消耗大量的时间和系统资源。因此,可以将商品列表数据缓存在内存中,每次用户访问时直接从缓存中获取数据,避免频繁读取数据库,提升系统的响应速度。</p><p><strong>2.当系统的访问频率较低时,可能不必使用缓存。</strong></p><p>如果某个数据只会偶尔被访问,那么将其缓存起来可能会浪费资源。在这种情况下,可以根据具体需求来决定是否需要使用缓存。例如,某个网站的新闻页面中的评论数可能会变化,但用户访问评论数的频率较低,那么可以不必缓存评论数。</p><h3 id="二、数据的更新频率"><a href="#二、数据的更新频率" class="headerlink" title="二、数据的更新频率"></a>二、数据的更新频率</h3><p><strong>1.当数据的更新频率较高时,使用缓存需要考虑缓存的一致性和更新机制。</strong></p><p>如果某个数据经常被更新,而缓存的数据没有及时更新,将会引发数据不一致的问题。在这种情况下，需要使用一些缓存更新策略例如定时更新缓存或通过触发更新事件来实时更新缓存数据。</p><p><strong>2.当数据的更新频率较低时，使用缓存可以减轻数据库的负载，并提高系统的响应能力。</strong></p><p>例如，某个系统中的配置文件数据一般较少改变可以将其缓存在内存中，避免频繁读取数据库，提高系统的性能。</p><h3 id="三、数据的访问模式"><a href="#三、数据的访问模式" class="headerlink" title="三、数据的访问模式"></a>三、数据的访问模式</h3><p><strong>1.<strong>如果某个数据具</strong>有明显的热点访问模式</strong>，即某些数据被频繁访问而其他数据很少被访问，可以考虑使用缓存。</p><p>例如，在一个社交网络中，用户的个人信息是频繁被访问的数据，可以将其缓存起来，减少数据库的访问次数。</p><p><strong>2.<strong>如果数据的</strong>访问模式比较随机</strong>，或者<strong>每个数据的访问频率相差不大</strong>那么使用缓存可能无法带来明显的性能提升，甚至可能增加系统的复杂性。</p><p>在这种情况下，可以考虑其他的性能优化方案，如数据库索引优化、查询优化等。</p><p>客户端缓存可以分成<strong>HTTP缓存</strong>和<strong>本地缓存</strong>，<strong>HTTP缓存</strong>可以分为<strong>强缓存</strong>和<strong>协商缓存</strong>，而常见的<strong>本地缓存</strong>包括<strong>Cookie</strong>、<strong>LocalStorage</strong> 和 <strong>SessionStorage</strong> 等</p><h1 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h1><p><strong>http缓存分文强制缓存和协商缓存</strong>,主要用来在客户端存储一些不经常变化的的静态文件，如图片、CSS、JS等。Http缓存流程如下:</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202409061554542.png" alt="img"></p><h3 id="强制缓存（强缓存）"><a href="#强制缓存（强缓存）" class="headerlink" title="强制缓存（强缓存）"></a>强制缓存（强缓存）</h3><p>浏览器在请求某一个资源时，会先获取资源的 header 信息，判断是否命中强缓存（请求头中的cache-control和expires信息），若命中，则直接从缓存中获取资源信息，包括header信息，本次请求就不会与服务器通信。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202409061555389.png" alt="img"></p><p>HTTP的缓存机制主要在<strong>响应头</strong>中进行设置，主要控制字段为 <code>Expries</code> 和 <code>Cache-Control</code></p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p><code>Expires</code>意为“到期”，是 HTTP&#x2F;1.0 中定义的一个响应头字段，用于指定资源的到期时间，即资源在客户端缓存中的有效期。它的值是一个GMT格式的日期时间字符串。比如说将某一资源设置响应头为: Expires: new Date(“2024-4-20 23:59:59”);</p><p>因为<code>Expires</code>判断强缓存是否过期的机制是:获取本地时间戳，并对先前拿到的资源文件中的<code>Expires</code>字段的时间做比较。来判断是否需要对服务器发起请求。因此它就会受到客户端时间的影响，而这就有可能会导致出现错误。</p><p>也就是说，<code>Expires</code>过度依赖本地时间，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。因此现在我们都是用<code>Cache-Control</code>来代替<code>Expres</code>了。</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p><code>Cache-Control</code>是HTTP&#x2F;1.1中最重要的缓存控制字段之一，它可以指定缓存行为的各种指令。使用方法例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: mime.<span class="hljs-title function_">lookup</span>(ext),<br>        <span class="hljs-string">&#x27;Cache-Control&#x27;</span>: <span class="hljs-string">&#x27;max-age=86400&#x27;</span>, <span class="hljs-comment">// 一天</span><br>      &#125;)<br><br></code></pre></td></tr></table></figure><p><code>Cache-Control:max-age=N</code>，N就是需要缓存的秒数。从第一次请求资源的时候开始，往后N秒内，资源若再次请求，则直接从缓存中读取，不会往服务器再发送一次请求。</p><p><code>Cache-control</code>中因为max-age后面的值是一个滑动时间，从服务器第一次返回该资源时开始倒计时。所以也就不需要比对客户端和服务端的时间，解决了<code>Expires</code>所存在的巨大漏洞。</p><p>它常见的指令有：</p><blockquote><ul><li><code>public</code>：表示响应可以被任何缓存（包括代理服务器）缓存。</li><li><code>private</code>：表示响应只能被客户端缓存，而不允许被代理服务器缓存。</li><li><code>s-maxage=&lt;seconds&gt;</code>：类似于<code>max-age</code>，但仅适用于代理服务器缓存。</li><li><code>no-cache</code>：表示缓存内容需要重新验证，客户端每次都要向服务器发送请求进行确认。</li><li><code>no-store</code>：表示不缓存任何内容，每次请求都要向服务器发送请求。</li></ul></blockquote><h4 id="强缓存的缺点"><a href="#强缓存的缺点" class="headerlink" title="强缓存的缺点"></a>强缓存的缺点</h4><ul><li>当用户第一次访问时，服务器会返回资源，并在响应头中设置缓存时间，当用户再次访问时，浏览器会根据缓存时间判断是否使用缓存，如果缓存时间未过期，则使用缓存，如果过期则重新请求资源，这样会导致用户第一次访问时，加载时间较长，用户体验不好。</li><li>如果后端改了数据，但是名字没有改变，浏览器不会重新请求，导致数据不是最新的。</li><li>后端资源修改了，前端无法实时获取最新资源。（通常都在文件名后面携带一串hash值，只要资源被修改，hash值就会更改，也就是文件名被修改了，因次浏览器一定会重新请求）</li><li>通过浏览器url地址栏发送的get请求，无法被强缓存，因为浏览器会忽略缓存，直接请求服务器，但是通过页面上的链接、表单提交、ajax请求等方式发送的get请求，可以被强缓存。</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存是 HTTP 缓存的一种机制，它通过在请求和响应中使用一些特定的头部信息来协商客户端和服务器之间的缓存行为。这种缓存机制允许客户端在重新获取资源时向服务器询问该资源的状态，并根据服务器返回的状态来决定是否使用缓存。</p><p>在协商缓存中，主要使用的头部字段包括：</p><ol><li><strong>Last-Modified &#x2F; If-Modified-Since：</strong><ul><li>当服务器响应一个资源请求时，会在响应头中包含 <code>Last-Modified</code> 字段，表示资源的最后修改时间。</li><li>当客户端再次请求相同资源时，会在请求头中包含 <code>If-Modified-Since</code> 字段，值为上一次获取资源时服务器返回的 <code>Last-Modified</code> 时间。</li><li>服务器收到带有 <code>If-Modified-Since</code> 字段的请求后，会比较该字段的值与资源的最后修改时间，如果资源的最后修改时间晚于 <code>If-Modified-Since</code> 字段的值，则返回资源内容和状态码 <code>200 OK</code>；如果资源的最后修改时间早于或等于 <code>If-Modified-Since</code> 字段的值，则返回状态码 <code>304 Not Modified</code>，告知客户端可以使用缓存的资源。</li></ul></li><li><strong>ETag &#x2F; If-None-Match：</strong><ul><li>当服务器响应一个资源请求时，可以在响应头中包含 <code>ETag</code> 字段，表示资源的标识符。</li><li>当客户端再次请求相同资源时，可以在请求头中包含 <code>If-None-Match</code> 字段，值为上一次获取资源时服务器返回的 <code>ETag</code>。</li><li>服务器收到带有 <code>If-None-Match</code> 字段的请求后，会比较该字段的值与资源的当前 <code>ETag</code>，如果两者相等，则返回状态码 <code>304 Not Modified</code>，告知客户端可以使用缓存的资源；如果两者不相等，则返回新的资源内容和状态码 <code>200 OK</code>。</li></ul></li></ol><p>就比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: mime.<span class="hljs-title function_">lookup</span>(ext),<br>        <span class="hljs-string">&#x27;etag&#x27;</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;content&#125;</span>`</span><br>        <span class="hljs-comment">// &#x27;Last-Modified&#x27;: stats.mtimeMs //时间戳</span><br>      &#125;)<br><span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filePath) <span class="hljs-comment">// 读取文件</span><br>      <span class="hljs-keyword">const</span> &#123; ext &#125; = path.<span class="hljs-title function_">parse</span>(filePath);<br>      <span class="hljs-keyword">const</span> timeStamp = req.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;if-modified-since&#x27;</span>];<br>      <span class="hljs-keyword">let</span> status = <span class="hljs-number">200</span>;<br>      <span class="hljs-keyword">if</span> (timeStamp &amp;&amp; <span class="hljs-title class_">Number</span>(timeStamp) === stats.<span class="hljs-property">mtimeMs</span>) &#123;<br>        status = <span class="hljs-number">304</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p>通过以上操作，我们就可以实现一个简单的协商缓存了。需要注意的是，之所以会有<code>ETag / If-None-Match</code>，是因为：</p><ul><li><code>Last-Modified</code>标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li><li>如果某些文件被修改了，但是内容并没有任何变化，而<code>Last-Modified</code>却改变了，导致文件没法使用缓存</li><li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>HTTP缓存是通过在客户端和服务器之间存储已获取过的资源副本来提高网站性能和加载速度的一种技术。它分为强缓存和协商缓存两种类型。</p><p>强缓存通过设置特定的响应头字段（如<code>Cache-Control</code>和<code>Expires</code>），告知客户端在一定的有效期内直接从本地缓存中获取资源，而无需再次向服务器发送请求。强缓存可以减少网络流量和延迟，提高网站性能和加载速度，降低服务器负载，并支持离线浏览。常见的控制字段有<code>ublic、private、s-maxage、no-cache和no-store</code>。</p><p>协商缓存则是通过在请求和响应中使用特定的头部信息（如<code>Last-Modified / If-Modified-Since</code>和<code>ETag / If-None-Match</code>）来协商客户端和服务器之间的缓存行为。当客户端再次请求资源时，会根据服务器返回的状态码来决定是否使用缓存。如果资源未过期，则返回状态码<code>200 OK</code>；如果资源过期，则返回状态码<code>304 Not Modified</code>，告知客户端可以使用缓存的资源。</p>]]></content>
    
    
    <categories>
      
      <category>Leak Filling</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front end</tag>
      
      <tag>http</tag>
      
      <tag>cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查漏补缺-前端安全之XSS与CSRF</title>
    <link href="/2024/09/06/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E4%B8%8ECSRF/"/>
    <url>/2024/09/06/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E4%B8%8ECSRF/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>XSS(<code>Cross</code> <code>Site</code> <code>Scripting</code>)跨站脚本攻击</p><blockquote><p>简称本应为<code>css</code>，但是为了防止与CSS(Cascading Style Sheets，层叠样式表)搞混，就取为<code>xss</code></p></blockquote><p>跨站脚本攻击就是用 JS 脚本攻击，案例如下：</p><h2 id="情景模拟"><a href="#情景模拟" class="headerlink" title="情景模拟"></a>情景模拟</h2><p>假设有一个前后端不分离的网站，后端用<code>express</code>搭建，文件 <code>app.js</code> 内容如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>) <span class="hljs-comment">// npm i express</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><span class="hljs-keyword">const</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ejs&#x27;</span>); <span class="hljs-comment">// npm i ejs</span><br><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>)); <span class="hljs-comment">// views的文件都会被当作模板被读到</span><br>app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">&#x27;html&#x27;</span>, ejs.<span class="hljs-property">__express</span>);<br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;html&#x27;</span>); <span class="hljs-comment">// 让模板引擎生效</span><br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123; <span class="hljs-comment">// 定义一个跟路径</span><br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123;<span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;express&#x27;</span>, <span class="hljs-attr">xss</span>: req.<span class="hljs-property">query</span>.<span class="hljs-property">xss</span>&#125;) <span class="hljs-comment">// res.render向前端输出</span><br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;listening on 3000&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>而其返回的 <code>HTML</code> 页面 <code>index.html</code> 内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%= title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&lt;%= title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello &lt;%= title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &lt;%- xss %&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在在浏览器中输入URL：<a href="http://localhost:3000/?xss=123">http://localhost:3000/?xss=123</a> ，title已经被默认赋值为 <code>express</code>，<code>xss</code>则被赋值为 123，可以得到如下页面</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202409181311486.webp" alt="1.png"></p><p>如果这时，我们把参数换成一个<code>script</code>标签，并且在<code>script</code>里面写个<code>alert</code>，用来模拟脚本攻击，具体URL为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://localhost:3000/?xss=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;你被攻击了&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202409181314619.webp" alt="1.gif"></p><p>URL里可以设置任何类型的参数，所以理论上可以写一个输入框，这样用户可能在访问网址时弹出输入框，并误以为这是银行网站自己弹出的内容，从而在输入框中输入如密码等重要信息，而黑客已经在后台获取了这些资料</p><h3 id="XSS的危害"><a href="#XSS的危害" class="headerlink" title="XSS的危害"></a><strong>XSS的危害</strong></h3><ol><li>窃取<code>cookie</code>信息：黑客可以在其他电脑上模拟登录状态</li><li>可以监听用户行为：可以监听用户点击键盘的行为，得到用户信息</li><li>伪造登录窗口</li><li>在你的页面生成浮窗广告</li></ol><p>浮窗广告例子：在body中添加一个 <code>div</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://localhost:3000/?xss=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div);div.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&#x27;300px&#x27;</span>;div.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;200px&#x27;</span>;div.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&#x27;1px solid black&#x27;</span>;div.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">&#x27;fixed&#x27;</span>;div.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = <span class="hljs-string">&#x27;300px&#x27;</span>;div.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">&#x27;300px&#x27;</span>;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202409181339587.webp" alt="2.gif"></p><h2 id="如何注入？"><a href="#如何注入？" class="headerlink" title="如何注入？"></a><strong>如何注入？</strong></h2><p>那么问题来了，XSS是在URL中写入参数，用户又不会自己入侵自己，如何将脚本放到别人的客户端上运行呢？</p><ol><li>反射型攻击：在<code>url</code>中写入参数，也就是上面的例子，比如攻击者发送的钓鱼短信等等，如果受害者点击并且执行，就会执行恶意脚本</li></ol><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202409181320389.webp" alt="img"></p><ol start="2"><li>存储型攻击：这种情况更加复杂一些，比如某网站存在一个评论区，我在评论区输入脚本，那么连带脚本的这部分内容就会被存入到数据库中，其他受害者点击这些评论时（可能模拟为某些按钮或文本），就有可能触发这类内容</li></ol><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202409181322257.webp" alt="img"></p><ol start="3"><li><p>DOM型攻击：一种基于 HTML 解析 DOM 过程中的安全漏洞进行的跨站攻击,攻击的过程与反射型XSS攻击极其类似，差异在于反射型XSS会把攻击脚本传递给服务器，而DOM型XSS不需要，从而可以绕过WAF、躲避服务端的检测。</p><p>DOM型XSS攻击通常也是攻击者诱导用户访问一个恶意网站，用户在输入数据后，js脚本将这些内容组合成被篡改的DOM片段，并在其中注入恶意脚本，而浏览器只要解析这些DOM片段，就会执行这些恶意脚本，从而窃取用户信息。</p></li></ol><h2 id="如何防范XSS"><a href="#如何防范XSS" class="headerlink" title="如何防范XSS"></a>如何防范XSS</h2><ol><li>对输入参数进行强校验，把不安全字符（如 &lt;, &gt;, &#x2F; 等) 过滤，从而避免浏览器执行这些内容</li><li>将用户输入的内容返回到页面上时，同样进行校验，防止被解析为HTML标签</li><li>使用 <code>HTTPOnly</code> cookie，这样 js 脚本不能读取到 cookie 信息</li><li>使用如验证码等安全控件来应对一些特殊页面（登录、支付页面）</li><li>设置 <code>CSP</code>（<code>Content Security Policy</code>），通过白名单和黑名单限制加载的资源类型和来源，从而防止恶意脚本的加载和执行</li><li>使用 <code>innerText</code> 或 <code>textContent</code> 等更安全的 API 取代 <code>innerHTML</code></li><li>限制用户输入</li><li>提示用户小心恶意链接</li></ol><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p><code>CSRF</code> (<code>Cross</code> <code>Site</code> <code>Request</code> <code>Forgery</code>) 跨站请求伪造</p><p>是指指恶意攻击者利用<strong>用户已经登录其他网站的“身份”</strong>来<strong>伪造用户的请求</strong></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202409181339657.webp" alt="img"></p><p>受害者正常访问 aa.com ，其登录状态保存在浏览器中</p><p>而如果其访问 bb.com（恶意网站），网站会利用同一个浏览器中 aa.com 的登录状态，直接向 aa.com 发送其他恶意请求</p><h2 id="如何防范"><a href="#如何防范" class="headerlink" title="如何防范"></a>如何防范</h2><ol><li>利用好<code>Cookie</code>的<code>SameSite</code>属性，防止跨站点使用 <code>cookie</code></li><li>服务端验证请求来源，比如<code>Origin</code>字段记录了请求来源地址，杜绝第三方站点请求源</li><li>在用户进行敏感操作前进行用户身份验证</li><li>使用 <code>CSRF Token</code>，在提交请求时一并提交，由服务端进行验证</li><li>设置 <code>CSP</code>（<code>Content Security Policy</code>），通过白名单和黑名单限制加载的资源类型和来源，从而防止恶意脚本的加载和执行</li></ol>]]></content>
    
    
    <categories>
      
      <category>Leak Filling</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front end</tag>
      
      <tag>http</tag>
      
      <tag>safe</tag>
      
      <tag>xss</tag>
      
      <tag>csrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/22/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/08/22/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>前端基础<br>js基本类型、数据类型</p><p>this指向、作用域</p><p>输入url到用户看到界面</p><p>浏览器是多线程的还是单线程的，有哪些线程</p><p>React vue这种前端框架的作用是什么? 优势好处?</p><p>虚拟 dom 用来做什么的? 如何更新？</p><p>从 url 到渲染过程?</p><p>https加密过程?</p><p>https基于什么?</p><p>重排重绘什么环节区别?</p><p>数据库</p><p>事件循环</p><p>快排复杂度?</p><p>TCP&#x2F;IP 如何做到可靠性传输?</p><p>性能优化手段有哪些</p><p>代码</p><p>this 和作用域</p><p>返回括号匹配结果</p><p>异步任务 2</p><p>平铺数组转树形结构</p><p>回答执行结果</p><p>合并两个有序数组</p><p>简单的实现 Promise.all</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录10 动态规划</title>
    <link href="/2024/07/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9510-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2024/07/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9510-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划基础"><a href="#动态规划基础" class="headerlink" title="动态规划基础"></a>动态规划基础</h1><h2 id="什么是动规？"><a href="#什么是动规？" class="headerlink" title="什么是动规？"></a>什么是动规？</h2><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题<strong>有很多重叠子问题</strong>，使用动态规划是最有效的。</p><p>动规问题的特点是<strong>每一个状态一定是由上一个状态推导出来的</strong>，这是与贪心的重要区别（贪心不推导状态，直接选取局部最优解）</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="LeetCode-509-斐波那契数"><a href="#LeetCode-509-斐波那契数" class="headerlink" title="LeetCode 509 斐波那契数"></a>LeetCode 509 斐波那契数</h2><p><a href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接(opens new window)</a></p><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) &#x3D; 0，F(1) &#x3D; 1 F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>示例 1：</p><ul><li>输入：2</li><li>输出：1</li><li>解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</li></ul><p>示例 2：</p><ul><li>输入：3</li><li>输出：2</li><li>解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</li></ul><p>示例 3：</p><ul><li>输入：4</li><li>输出：3</li><li>解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</li></ul><p>提示：</p><ul><li>0 &lt;&#x3D; n &lt;&#x3D; 30</li></ul><h3 id="暴力方法"><a href="#暴力方法" class="headerlink" title="暴力方法"></a>暴力方法</h3><p>如果输入的n大于2，就逐个累加，得到长度为n+1的斐波那契数列数组，返回最后一个数即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fib = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">let</span> dp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp)<br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="动规"><a href="#动规" class="headerlink" title="动规"></a>动规</h3><p>状态转移方程为：dp[i] &#x3D; dp[i-1] + dp[i-2]，因此只需要两个变量记录状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fib = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-comment">// 动规状态转移中，当前结果只依赖前两个元素的结果，所以只要两个变量代替dp数组记录状态过程。将空间复杂度降到O(1)</span><br>    <span class="hljs-keyword">let</span> pre1 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> pre2 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> temp<br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        temp = pre1<br>        pre1 = pre1 + pre2<br>        pre2 = temp<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre1<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-647-回文子串"><a href="#LeetCode-647-回文子串" class="headerlink" title="LeetCode 647 回文子串"></a>LeetCode 647 回文子串</h2><p><a href="https://leetcode.cn/problems/palindromic-substrings/">力扣题目链接(opens new window)</a></p><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><ul><li>输入：”abc”</li><li>输出：3</li><li>解释：三个回文子串: “a”, “b”, “c”</li></ul><p>示例 2：</p><ul><li>输入：”aaa”</li><li>输出：6</li><li>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</li></ul><p>提示：输入的字符串长度不会超过 1000 。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>先找到所有子串，然后判断每个子串是否是回文串，复杂度O(n^3)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> countSubstrings = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; s.<span class="hljs-property">length</span>; index++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> end = index; end &lt; s.<span class="hljs-property">length</span>; end++) &#123;<br>            <span class="hljs-keyword">let</span> str = s.<span class="hljs-title function_">substring</span>(index, end + <span class="hljs-number">1</span>)<br>            count++<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> flag = <span class="hljs-number">0</span>; flag &lt; str.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>; flag++) &#123;<br>                <span class="hljs-keyword">if</span> (str[flag] != str[str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - flag]) &#123;<br>                    count--<br>                    <span class="hljs-keyword">break</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/20230102170752.png" alt="img"></p><p>分析可知，要判断字符串 d[i][j] 是否为回文子串，可以先看 d[i+1][j-1] 是否为回文串；</p><p>接下来确定递推公式：</p><p>如果 d[i] !&#x3D; d[j]，则d[i][j] 一定不是回文子串</p><p>如果 d[i] &#x3D;&#x3D; d[j]，分两种情况：</p><p>​当 j-i &lt;&#x3D; 1 时，d[i][j] 是回文子串</p><p>​当 j-1 &gt; 1时，如果 d[i+1][j-1] 是回文子串，则 d[i][j] 是回文子串</p><p>递归公式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>    <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 </span><br>        result++;<br>        dp[i][j] = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况二</span><br>        result++;<br>        dp[i][j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，可以将回文子串映射到二维数组上，如果对应位置为true，则是回文子串，如果为false，则不是;</p><p>先将所有 d[i][j] 初始化为 false，不能在初始化时就完成判断；</p><p>根据递推公式，d[i][j] 是根据其左下角的  d[i+1][j-1] 得到的，因此在遍历时应当从下往上，从左往右遍历</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/20210121171032473-20230310132134822.jpg" alt="647.回文子串"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">countSubstrings</span> = (<span class="hljs-params">s</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> strLen = s.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> numOfPalindromicStr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title class_">Array</span>(strLen), <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(strLen).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; strLen; j++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= j; i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] === s[j]) &#123;<br>                <span class="hljs-keyword">if</span>((j - i) &lt; <span class="hljs-number">2</span>) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>                numOfPalindromicStr += dp[i][j] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> numOfPalindromicStr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-70-爬楼梯"><a href="#LeetCode-70-爬楼梯" class="headerlink" title="LeetCode 70 爬楼梯"></a>LeetCode 70 爬楼梯</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接(opens new window)</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><ul><li>输入： 2</li><li>输出： 2</li><li>解释： 有两种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶</li><li>2 阶</li></ul></li></ul><p>示例 2：</p><ul><li>输入： 3</li><li>输出： 3</li><li>解释： 有三种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-comment">// dp[i] 为第 i 阶楼梯有多少种方法爬到楼顶</span><br>    <span class="hljs-comment">// dp[i] = dp[i - 1] + dp[i - 2]</span><br>    <span class="hljs-keyword">let</span> dp = [<span class="hljs-number">1</span> , <span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-746-使用最小花费爬楼梯"><a href="#Leetcode-746-使用最小花费爬楼梯" class="headerlink" title="Leetcode 746 使用最小花费爬楼梯"></a>Leetcode 746 使用最小花费爬楼梯</h2><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接(opens new window)</a></p><p><strong>旧题目描述</strong>：</p><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例 1：</p><ul><li>输入：cost &#x3D; [10, 15, 20]</li><li>输出：15</li><li>解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</li></ul><p>示例 2：</p><ul><li>输入：cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</li><li>输出：6</li><li>解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</li></ul><p>提示：</p><ul><li>cost 的长度范围是 [2, 1000]。</li><li>cost[i] 将会是一个整型数据，范围为 [0, 999] 。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-keyword">function</span> (<span class="hljs-params">cost</span>) &#123;<br>    <span class="hljs-keyword">let</span> dp = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>]) &gt; (dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>])) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-property">length</span>]<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-62-不同路径"><a href="#Leetcode-62-不同路径" class="headerlink" title="Leetcode 62 不同路径"></a>Leetcode 62 不同路径</h2><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接(opens new window)</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202409012321728.png" alt="img"></p><ul><li>输入：m &#x3D; 3, n &#x3D; 7</li><li>输出：28</li></ul><p>示例 2：</p><ul><li>输入：m &#x3D; 2, n &#x3D; 3</li><li>输出：3</li></ul><p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 3：</p><ul><li>输入：m &#x3D; 7, n &#x3D; 3</li><li>输出：28</li></ul><p>示例 4：</p><ul><li>输入：m &#x3D; 3, n &#x3D; 3</li><li>输出：6</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; m, n &lt;&#x3D; 100</li><li>题目数据保证答案小于等于 2 * 10^9</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-keyword">function</span> (<span class="hljs-params">m, n</span>) &#123;<br>    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>))<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n ; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j &amp;&amp; i == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">let</span> top = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>                top = dp[i-<span class="hljs-number">1</span>][j]<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>                right = dp[i][j-<span class="hljs-number">1</span>]<br>            &#125;<br>            dp[i][j] = top + right<br>        &#125;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp)<br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录09 贪心算法</title>
    <link href="/2024/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9509-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9509-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心的本质是在<strong>每一阶段都选择局部最优</strong>，从而<strong>试图达到全局最优</strong></p><p>如何判断是否适合贪心？手动模拟，如果模拟可行就试一试，如果不可行则考虑动规。</p><h2 id="LeetCode-455-分发饼干"><a href="#LeetCode-455-分发饼干" class="headerlink" title="LeetCode 455. 分发饼干"></a>LeetCode 455. 分发饼干</h2><p><a href="https://leetcode.cn/problems/assign-cookies/">力扣题目链接</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例  1:</p><ul><li>输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</li><li>输出: 1 解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。</li></ul><p>示例  2:</p><ul><li>输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</li><li>输出: 2</li><li>解释:你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2.</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; g.length &lt;&#x3D; 3 * 10^4</li><li>0 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^4</li><li>1 &lt;&#x3D; g[i], s[j] &lt;&#x3D; 2^31 - 1</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 让胃口小的人先吃，给他们吃能满足的最小的饼干</span><br><br>    <span class="hljs-comment">// 首先对饼干排序</span><br>    g.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> a-b)<br>    s.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> a-b)<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-comment">// 对于每个人，在 s 中寻找能满足胃口的最小饼干并吃掉，如果没有，则后面的人也无法满足直接结束</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-property">length</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) &#123;<br>                flag = <span class="hljs-number">1</span>;<br>                s.<span class="hljs-title function_">splice</span>(j,<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ( flag ) &#123;<br>            count++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> count<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-376-摆动序列"><a href="#Leetcode-376-摆动序列" class="headerlink" title="Leetcode 376. 摆动序列"></a>Leetcode 376. 摆动序列</h2><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">力扣题目链接(opens new window)</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和  [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><ul><li>输入: [1,7,4,9,2,5]</li><li>输出: 6</li><li>解释: 整个序列均为摆动序列。</li></ul><p>示例 2:</p><ul><li>输入: [1,17,5,10,13,15,10,5,16,8]</li><li>输出: 7</li><li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li></ul><p>示例 3:</p><ul><li>输入: [1,2,3,4,5,6,7,8,9]</li><li>输出: 2</li></ul>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录08 回溯算法</title>
    <link href="/2024/07/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9508-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9508-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录07 二叉树</title>
    <link href="/2024/07/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9507-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/07/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9507-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录06 栈与队列</title>
    <link href="/2024/07/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9506-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2024/07/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9506-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Stack</tag>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录05 双指针法</title>
    <link href="/2024/07/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9505-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    <url>/2024/07/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9505-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Double Pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录04 字符串</title>
    <link href="/2024/07/04/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9504-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/07/04/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9504-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h1 id="Leetcode-344-反转字符串"><a href="#Leetcode-344-反转字符串" class="headerlink" title="Leetcode 344.反转字符串"></a>Leetcode 344.反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接(opens new window)</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reverseString = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> temp<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(s.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>); i++) &#123;<br>        temp = s[i]<br>        s[i] = s[s.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>-i]<br>        s[s.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>-i] = temp<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Leetcode-541-反转字符串II"><a href="#Leetcode-541-反转字符串II" class="headerlink" title="Leetcode 541. 反转字符串II"></a>Leetcode 541. 反转字符串II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “bacdfeg”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reverseStr = <span class="hljs-keyword">function</span> (<span class="hljs-params">s, k</span>) &#123;<br>    <span class="hljs-keyword">const</span> len = s.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> resArr = s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resArr)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">2</span> * k) &#123;  <span class="hljs-comment">// 每隔 2k 个字符的前 k 个字符进行反转</span><br>        <span class="hljs-keyword">let</span> l = i - <span class="hljs-number">1</span>, r = i + k &gt; len ? len : i + k;<br>        <span class="hljs-keyword">while</span> (++l &lt; --r) [resArr[l], resArr[r]] = [resArr[r], resArr[l]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> resArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Leetcode-151-翻转字符串里的单词"><a href="#Leetcode-151-翻转字符串里的单词" class="headerlink" title="Leetcode 151. 翻转字符串里的单词"></a>Leetcode 151. 翻转字符串里的单词</h1><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接(opens new window)</a></p><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good  example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reverseWords = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> wordArray = s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; wordArray.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (wordArray[i] == <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>            wordArray.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>)<br>            i--<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(wordArray.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>); i++) &#123;<br>        <span class="hljs-keyword">let</span> temp = wordArray[i]<br>        wordArray[i] = wordArray[wordArray.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i]<br>        wordArray[wordArray.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i] = temp<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wordArray)<br>    <span class="hljs-keyword">let</span> word= wordArray.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">return</span> word<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录03 哈希表</title>
    <link href="/2024/07/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9503-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2024/07/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9503-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表是根据<strong>值</strong>而<strong>直接进行访问</strong>的数据结构，数组就是一张哈希表，哈希表中的值就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202409021007490.png" alt="哈希表1"></p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里</strong></p><h2 id="Leetcode-242-有效的字母异位词"><a href="#Leetcode-242-有效的字母异位词" class="headerlink" title="Leetcode 242.有效的字母异位词"></a>Leetcode 242.有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接(opens new window)</a></p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true</p><p>示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用哈希表存储字母在s中出现次数，在t中每出现一次就减去一次，如果减去时发现没有该字母，或该字母已经减到0，则说明缺少该字母或超出了该字母的出现次数，直接返回false，全部遍历完仍没有问题，则返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isAnagram = <span class="hljs-keyword">function</span> (<span class="hljs-params">s, t</span>) &#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> != t.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(s[i])) &#123;<br>            map.<span class="hljs-title function_">set</span>(s[i], <span class="hljs-number">1</span> + map.<span class="hljs-title function_">get</span>(s[i]))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.<span class="hljs-title function_">set</span>(s[i], <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(t[i])) &#123;<br>            map.<span class="hljs-title function_">set</span>(t[i], map.<span class="hljs-title function_">get</span>(t[i])-<span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map,i)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-349-两个数组的交集"><a href="#Leetcode-349-两个数组的交集" class="headerlink" title="Leetcode 349. 两个数组的交集"></a>Leetcode 349. 两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣题目链接(opens new window)</a></p><p>题意：给定两个数组，编写一个函数来计算它们的交集。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200818193523911.png" alt="349. 两个数组的交集"></p><p><strong>说明：</strong> 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>将nums1数组中出现的元素记录在hashmap中，值设置为1，nums2中的元素如果在hashmap中出现，则设为0（防重复），同时记录到数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> intersection = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = []<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++)&#123;<br>        map.<span class="hljs-title function_">set</span>(nums1[i], <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums2.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(nums2[i])) &#123;<br>            map.<span class="hljs-title function_">set</span>(nums2[i], <span class="hljs-number">0</span>)<br>            result.<span class="hljs-title function_">push</span>(nums2[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-202-快乐数"><a href="#Leetcode-202-快乐数" class="headerlink" title="Leetcode 202. 快乐数"></a>Leetcode 202. 快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">力扣题目链接(opens new window)</a></p><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 &#x3D; 82<br>8^2 + 2^2 &#x3D; 68<br>6^2 + 8^2 &#x3D; 100<br>1^2 + 0^2 + 0^2 &#x3D; 1</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>由于结果可能重复，所以用hashmap记录结果，如果已经有该结果，直接false，如果没有，就一直计算，直到结果为1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isHappy = <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">while</span> (!map.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">let</span> stringN = n.<span class="hljs-title function_">toString</span>()<br>        n = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; stringN.<span class="hljs-property">length</span>; i++) &#123;<br>            n += stringN[i] * stringN[i]<br>        &#125;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(n)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.<span class="hljs-title function_">set</span>(n, <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-1-两数之和"><a href="#Leetcode-1-两数之和" class="headerlink" title="Leetcode 1. 两数之和"></a>Leetcode 1. 两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</p><p>因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</p><p>所以返回 [0, 1]</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>因为每个数值对应的另一个值也是确定的，只需要判断其对应值存不存在，本质还是找存在的问题，可以用hashtable来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(nums[i]) &amp;&amp; map.<span class="hljs-title function_">get</span>(nums[i]) != i) &#123;<br>            <span class="hljs-keyword">return</span> [i, map.<span class="hljs-title function_">get</span>(nums[i]) ]<br>        &#125; <span class="hljs-keyword">else</span> &#123;            <br>            map.<span class="hljs-title function_">set</span>(target - nums[i], i)<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-454-四数相加II"><a href="#Leetcode-454-四数相加II" class="headerlink" title="Leetcode 454. 四数相加II"></a>Leetcode 454. 四数相加II</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接(opens new window)</a></p><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p><strong>例如:</strong></p><p>输入:</p><ul><li>A &#x3D; [ 1, 2]</li><li>B &#x3D; [-2,-1]</li><li>C &#x3D; [-1, 2]</li><li>D &#x3D; [ 0, 2]</li></ul><p>输出:</p><p>2</p><p><strong>解释:</strong></p><p>两个元组如下:</p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li></ol><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>分解为两个两数之和，前两个数的所有可能和存入一个map，后两个数的和应该与这个map对应</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fourSumCount = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2, nums3, nums4</span>) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> len = nums1.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(nums1[i]+nums2[j])) &#123;<br>                map.<span class="hljs-title function_">set</span>(nums1[i]+nums2[j], map.<span class="hljs-title function_">get</span>(nums1[i]+nums2[j]) + <span class="hljs-number">1</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.<span class="hljs-title function_">set</span>(nums1[i]+nums2[j], <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map)<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(<span class="hljs-number">0</span>-nums3[i]-nums4[j])) &#123;<br>                count += map.<span class="hljs-title function_">get</span>(<span class="hljs-number">0</span>-nums3[i]-nums4[j])<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-383-赎金信"><a href="#Leetcode-383-赎金信" class="headerlink" title="Leetcode 383. 赎金信"></a>Leetcode 383. 赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接(opens new window)</a></p><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canConstruct = <span class="hljs-keyword">function</span> (<span class="hljs-params">ransomNote, magazine</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; magazine.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(magazine[i])) &#123;<br>            map.<span class="hljs-title function_">set</span>(magazine[i], map.<span class="hljs-title function_">get</span>(magazine[i]) + <span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.<span class="hljs-title function_">set</span>(magazine[i], <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ransomNote.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(ransomNote[i])) &#123;<br>            map.<span class="hljs-title function_">set</span>(ransomNote[i], map.<span class="hljs-title function_">get</span>(ransomNote[i]) - <span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Hash Table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录02 链表</title>
    <link href="/2024/07/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9502-%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/07/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9502-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h1><p>链表是一种<strong>通过指针串联在一起</strong>的线性结构，每一个节点由两部分组成，一个是<strong>数据域</strong>一个是<strong>指针域</strong>（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链表的<strong>入口节点</strong>称为链表的<strong>头结点</strong>也就是<strong>head</strong>。</p><p>如图所示即为<strong>单链表</strong>：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/20200806194529815.png" alt="链表1"></p><p><strong>双链表：</strong>每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。既可以向前查询也可以向后查询。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202408191649579.png" alt="链表2"></p><p><strong>循环链表：</strong>就是链表首尾相连，可以用来解决约瑟夫环问题。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202408191650356.png" alt="链表4"></p><p><strong>存储方式：</strong>数组是在内存中是连续分布的，但链表在内存中不是连续分布的，而是通过指针域的指针链接在内存中各个节点。</p><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/202408191651946.png" alt="链表3"></p><h2 id="JavaScript-单链表定义"><a href="#JavaScript-单链表定义" class="headerlink" title="JavaScript 单链表定义"></a>JavaScript 单链表定义</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>val;<br>next = <span class="hljs-literal">null</span>;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = value<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录01 数组</title>
    <link href="/2024/07/01/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9501-%E6%95%B0%E7%BB%84/"/>
    <url>/2024/07/01/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%9501-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h1><p>数组是<strong>存放在连续内存空间上</strong>的相同类型数据的集合，可以方便的<strong>通过下标索引</strong>的方式获取到下标对应的数据。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/array.png" alt="array"></p><h2 id="JavaScript-数组基础"><a href="#JavaScript-数组基础" class="headerlink" title="JavaScript 数组基础"></a>JavaScript 数组基础</h2><ol><li><code>toString()</code>方法，将数组转换为逗号分隔的字符串，在需要时，<code>toString()</code>会自动调用。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits.<span class="hljs-title function_">toString</span>())<br><br><span class="hljs-comment">// Output: Banana,Orange,Apple,Mango</span><br><br><span class="hljs-comment">// document.getElementById(&quot;demo&quot;).innerHTML = fruits.toString(); </span><br><span class="hljs-comment">// document.getElementById(&quot;demo&quot;).innerHTML = fruits; </span><br><span class="hljs-comment">// 两种方式等价</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>join()</code>方法，将数组中元素用制定分隔符连接起来，输出字符串</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; * &quot;</span>))<br><br><span class="hljs-comment">// Output: Banana * Orange * Apple * Mango</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>pop()</code>方法删除最后一个元素，并返回该值；</p><p><code>push()</code>方法在最后添加一个元素，返回数组长度;</p><p><code>shift()</code>方法在删除第一个元素，并返回该值;</p><p><code>unshift()</code>方法在开头添加一个元素，返回数组长度;</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// pop()</span><br><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-keyword">var</span> x = fruits.<span class="hljs-title function_">pop</span>();      <br><span class="hljs-comment">// x 的值是 &quot;Mango&quot;</span><br><span class="hljs-comment">// fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;]</span><br><br><span class="hljs-comment">// push()</span><br><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-keyword">var</span> x =  fruits.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Kiwi&quot;</span>);   <br><span class="hljs-comment">//  x 的值是 5       </span><br><span class="hljs-comment">//  fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;, &quot;Kiwi&quot;]</span><br><br><span class="hljs-comment">// shift()</span><br><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-keyword">var</span> x = fruits.<span class="hljs-title function_">pop</span>();    <br><span class="hljs-comment">// x 的值是 &quot;Banana&quot;</span><br><span class="hljs-comment">// fruits = [&quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]</span><br><br><span class="hljs-comment">// unshift()</span><br><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-keyword">var</span> x =  fruits.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Kiwi&quot;</span>);   <br><span class="hljs-comment">//  x 的值是 5       </span><br><span class="hljs-comment">//  fruits = [&quot;Kiwi&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]</span><br></code></pre></td></tr></table></figure><ol start="4"><li>用索引号修改元素</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Kiwi&quot;</span>;        <br><span class="hljs-comment">// 把 fruits 的第一个元素改为 &quot;Kiwi&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>通过<code>length</code>属性获取数组长度</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits[fruits.<span class="hljs-property">length</span>] = <span class="hljs-string">&quot;Kiwi&quot;</span>;          <br><span class="hljs-comment">// 向 fruits 追加 &quot;Kiwi&quot;</span><br></code></pre></td></tr></table></figure><ol start="6"><li>通过<code>delete</code>运算符删除元素（会留下 undefined 空洞）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-keyword">delete</span> fruits[<span class="hljs-number">0</span>];           <br><span class="hljs-comment">// 把 fruits 中的首个元素改为 undefined</span><br></code></pre></td></tr></table></figure><ol start="7"><li><code>splice()</code>方法为数组添加新元素，第一个参数定义添加新元素的位置（拼接），第二个参数定义应删除多少元素，其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。返回删除项组成的数组。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-keyword">let</span> removed = fruits.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Lemon&quot;</span>, <span class="hljs-string">&quot;Kiwi&quot;</span>);<br><span class="hljs-comment">// fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Kiwi&quot;]</span><br><span class="hljs-comment">// removed = [&quot;Apple&quot;, &quot;Mango&quot;]</span><br></code></pre></td></tr></table></figure><ol start="8"><li><code>concat</code>方法合并数组（原数组不变），返回一个新的数组。可以有多个参数，也能以值作为参数。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">&quot;Cecilie&quot;</span>, <span class="hljs-string">&quot;Lone&quot;</span>];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-string">&quot;Emil&quot;</span>, <span class="hljs-string">&quot;Tobias&quot;</span>, <span class="hljs-string">&quot;Linus&quot;</span>];<br><span class="hljs-keyword">var</span> arr3 = [<span class="hljs-string">&quot;Robin&quot;</span>, <span class="hljs-string">&quot;Morgan&quot;</span>];<br><span class="hljs-keyword">var</span> myChildren = arr1.<span class="hljs-title function_">concat</span>(arr2, arr3);   <br><span class="hljs-comment">// 将arr1、arr2 与 arr3 连接在一起</span><br><span class="hljs-comment">// myChildren = [&quot;Cecilie&quot;, &quot;Lone&quot;, &quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;, &quot;Robin&quot;, &quot;Morgan&quot;]</span><br></code></pre></td></tr></table></figure><ol start="9"><li><code>slice()</code>方法从原数组中截取一段数组，而不改变原数组，第一个参数表示起始位置（包括），第二个表示结束位置（不包括），如果第二个参数省略，切出所有剩余部分；</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Lemon&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-keyword">var</span> citrus = fruits.<span class="hljs-built_in">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <br></code></pre></td></tr></table></figure><h2 id="JavaScript-数组排序"><a href="#JavaScript-数组排序" class="headerlink" title="JavaScript 数组排序"></a>JavaScript 数组排序</h2><ol><li><p><code>sort()</code>方法，最强大的数组方法之一</p><p>默认情况下，按照字符串顺序排序</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits.<span class="hljs-title function_">sort</span>(); <br><span class="hljs-comment">// Apple,Banana,Mango,Orange</span><br></code></pre></td></tr></table></figure><p>​ 而对于数值类型，需要添加比较函数，比较函数传入两个参数，并根据返回值的正负，判断顺序</p><p>​ 如 40 和 100，传入后，100-40&#x3D;60 &gt; 0，所以40 比 100 更大</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> points = [<span class="hljs-number">40</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">25</span>, <span class="hljs-number">10</span>];<br>points.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>)&#123;<span class="hljs-keyword">return</span> b - a&#125;); <br><span class="hljs-comment">// 100,40,25,10,5,1</span><br></code></pre></td></tr></table></figure><p>​ 同样的，也可以利用<code>Math.random()</code>进行随机排序，该方法返回0（包含）到1（不包含）的为随机数，这样就能获得一半概率a&gt;b，一半概率a&lt;b的情况，进行随机打乱</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> points = [<span class="hljs-number">40</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">25</span>, <span class="hljs-number">10</span>];<br>points.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()&#125;); <br></code></pre></td></tr></table></figure><p>​ 尽管对象有多种不同类型数据，也可以使用<code>sort()</code>方法的比较函数排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> cars = [<br>&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;Volvo&quot;</span>, <span class="hljs-attr">year</span>:<span class="hljs-number">2016</span>&#125;,<br>&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;Saab&quot;</span>, <span class="hljs-attr">year</span>:<span class="hljs-number">2001</span>&#125;,<br>&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;BMW&quot;</span>, <span class="hljs-attr">year</span>:<span class="hljs-number">2010</span>&#125;];<br>cars.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>)&#123;<span class="hljs-keyword">return</span> a.<span class="hljs-property">year</span> - b.<span class="hljs-property">year</span>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li><code>reverse()</code>方法，将数组倒序</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits.<span class="hljs-title function_">sort</span>();            <span class="hljs-comment">// 对 fruits 中的元素进行排序</span><br>fruits.<span class="hljs-title function_">reverse</span>();         <span class="hljs-comment">// Orange,Mango,Banana,Apple</span><br></code></pre></td></tr></table></figure><ol start="3"><li>如果只是要找到最大&#x2F;最小值，无需对整个数组排序，可以使用<code>Math.max()</code>或<code>Math.min()</code>方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Math.max.apply([1, 2, 3]) 等于 Math.max(1, 2, 3)。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myArrayMax</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, arr);<br>&#125;<br><br><span class="hljs-comment">// Math.min.apply([1, 2, 3]) 等于 Math.min(1, 2, 3)。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myArrayMin</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">min</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, arr);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JavaScript-数组迭代"><a href="#JavaScript-数组迭代" class="headerlink" title="JavaScript 数组迭代"></a>JavaScript 数组迭代</h2><ol><li><code>Array.forEach()</code>对每个数组元素调用一次回调，接受 3 个参数：项目值、项目索引、数组本身</li><li><code>Array.map()</code>方法通过对每个数组元素执行函数来创建<strong>新数组</strong>，不会对没有值的数组元素执行函数，也不会更改原始数组</li><li><code>Array.filter()</code>方法创建一个包含通过测试的数组元素的<strong>新数组</strong></li><li><code>Array.reduce()</code>方法在每个数组元素上运行函数，以生成（减少它）单个值,在数组中从左到右工作(<code>reduceRight()</code>方法则从右到左工作) ，不会减少原始数组。</li></ol><p>​ <code>reduce()</code>方法的回调函数接受四个参数，一个初始值（初始值也可以放在回调函数后，作为第二个大参数传入），和项目值、项目索引、数组本身</p><ol start="5"><li><code>Array.every()</code>检验数组中的所有值是否均满足函数要求，<code>Array.some()</code>则只检验是否有值满足（至少一个）</li><li><code>Array.find()</code>找到第一个满足要求的数组元素的值，<code>Array.findIndex()</code>则返回索引</li><li><code>Array.indexOf()</code>从头部开始搜索元素位置，<code>Array.lastIndexOf()</code>从尾部开始搜索</li></ol><h1 id="数组题目"><a href="#数组题目" class="headerlink" title="数组题目"></a>数组题目</h1><h2 id="LeetCode-704-二分查找-（二分法）"><a href="#LeetCode-704-二分查找-（二分法）" class="headerlink" title="LeetCode 704 二分查找 （二分法）"></a>LeetCode 704 二分查找 （二分法）</h2><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [-1,0,3,5,9,12], target = 9     <br>输出: 4       <br>解释: 9 出现在 nums 中并且下标为 4     <br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">输入: nums = [-1,0,3,5,9,12], target = 2     <br>输出: -1        <br>解释: 2 不存在 nums 中因此返回 -1        <br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用二分法的前提是<strong>有序</strong>数组，且<strong>无重复元素</strong>，在元素重复时，二分法得到的元素下标可能不唯一；</p><p>设置 left, mid, right 三个指针，每次都用中间位置作比较：</p><p>如果比目标大，就在左半边（升序情况）找，将 right更新为 mid - 1;</p><p>如果比目标小，就在右半边找，将 left 更新为 mid + 1;</p><p>如果相等，直接返回，</p><p>到最后，left, mid, right 三个值相等，再找就会使得left &gt; right，跳出循环，返回 -1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> search = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-comment">// right是数组最后一个数的下标，num[right]在查找范围内，是左闭右闭区间</span><br>    <span class="hljs-keyword">let</span> mid, left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 当left=right时，由于nums[right]在查找范围内，所以要包括此情况</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-comment">// 位运算 + 防止大数溢出</span><br>        mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 如果中间数大于目标值，要把中间数排除查找范围，所以右边界更新为mid-1；如果右边界更新为mid，那中间数还在下次查找范围内</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 去左面闭区间寻找</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 去右面闭区间寻找</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-27-移除元素"><a href="#LeetCode-27-移除元素" class="headerlink" title="LeetCode 27 移除元素"></a>LeetCode 27 移除元素</h2><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> removeElement = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, val</span>) &#123;<br>    <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != val) &#123;<br>            nums[k++] = nums[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> k<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-977-有序数组的平方-（双指针）"><a href="#LeetCode-977-有序数组的平方-（双指针）" class="headerlink" title="LeetCode 977 有序数组的平方 （双指针）"></a>LeetCode 977 有序数组的平方 （双指针）</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1：</p><ul><li>输入：nums &#x3D; [-4,-1,0,3,10]</li><li>输出：[0,1,9,16,100]</li><li>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</li></ul><p>示例 2：</p><ul><li>输入：nums &#x3D; [-7,-3,2,3,11]</li><li>输出：[4,9,9,49,121]</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortedSquares = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>    nums.<span class="hljs-title function_">map</span>( <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item*item)<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>, end = nums.<span class="hljs-property">length</span>-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(nums.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-keyword">let</span> left = nums[start] * nums[start]<br>    <span class="hljs-keyword">let</span> right = nums[end] * nums[end]<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>            result[i] = left<br>            start++<br>            left =  nums[start] * nums[start]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result[i] = right<br>            end--<br>            right =  nums[end] * nums[end]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-209-长度最小的子数组-（滑动窗口）"><a href="#Leetcode-209-长度最小的子数组-（滑动窗口）" class="headerlink" title="Leetcode 209 长度最小的子数组 （滑动窗口）"></a>Leetcode 209 长度最小的子数组 （滑动窗口）</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接(opens new window)</a></p><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><ul><li>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; target &lt;&#x3D; 10^9</li><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minSubArrayLen = <span class="hljs-keyword">function</span> (<span class="hljs-params">target, nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> result = nums.<span class="hljs-property">length</span>+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; nums.<span class="hljs-property">length</span>; i++)&#123;<br>        sum+=nums[i]<br>        <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>            <span class="hljs-keyword">if</span> (i - start + <span class="hljs-number">1</span> &lt; result)<br>            result = i - start + <span class="hljs-number">1</span><br>            sum -= nums[start]<br>            start++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result == nums.<span class="hljs-property">length</span> + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-59-螺旋矩阵II"><a href="#Leetcode-59-螺旋矩阵II" class="headerlink" title="Leetcode 59 螺旋矩阵II"></a>Leetcode 59 螺旋矩阵II</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接(opens new window)</a></p><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> generateMatrix = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">let</span> item = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">()=&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>))<br><br>    <span class="hljs-comment">// 画几圈？</span><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n/<span class="hljs-number">2</span>); i++ ) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n/<span class="hljs-number">2</span>) &amp;&amp; n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            a[i][i] = n*n<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 画四条边</span><br><br>        <span class="hljs-comment">// 上边</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t = i; t &lt; n - <span class="hljs-number">1</span> - i; t++) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>            a[i][t] = item<br>            a[t][n-<span class="hljs-number">1</span>-i] = item + (n - <span class="hljs-number">1</span> - <span class="hljs-number">2</span>*i)<br>            a[n-<span class="hljs-number">1</span>-i][n-<span class="hljs-number">1</span>-t] = item + <span class="hljs-number">2</span>*(n - <span class="hljs-number">1</span> - <span class="hljs-number">2</span>*i)<br>            a[n-<span class="hljs-number">1</span>-t][i] = item + <span class="hljs-number">3</span>*(n - <span class="hljs-number">1</span> - <span class="hljs-number">2</span>*i)<br>            item++<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>+i &lt; n-<span class="hljs-number">1</span>)&#123;<br>            <br>        item = a[<span class="hljs-number">1</span>+i][i]<br>        item++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apache-Jena 学习笔记</title>
    <link href="/2023/02/23/Apache-Jena%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/23/Apache-Jena%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>这是一个 W3C 的资源描述框架（RDF）和Jena （RDF的Java API）的教程。可以通过原型（Prototyping）快速学习，并快速转向实现。以下内容已经假定你已经对XML和Java都有一定的了解。</p><p>RDF 采用 XML 语法，许多熟悉 XML 的人会根据这种语法来理解 RDF。这是错误的，应该从数据模型的角度来理解 RDF。RDF 数据可以用 XML 表示，但是理解 XML 的语法比理解数据模型更重要。</p><p>可以从 <a href="jena.apache.org/download/index.cgi">Apache-jena</a> 下载 Jena API 的实现，包括本教程中使用的所有示例的工作源代码。</p><h1 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h1><p>资源描述框架（Resource Description Framework, RDF）是描述资源的标准（W3C推荐标准）</p><p>什么是资源？这是一个相当深刻的问题，且确切的定义仍有争议。</p><p>在这里，我们可以把它看作<strong>我们可以识别的任何东西</strong>。你可以是一个资源，就像你的主页，本教程，数字一和小说《Moby Dick》中的大白鲸一样。</p><p>本教程中的例子是关于人的。它们使用 <a href="https://www.w3.org/TR/vcard-rdf/">VCARDS 的 RDF 表示</a>。RDF的最佳思维表现模式是由节点和弧组成的图。在 RDF 中，一个简单的 vcard 可能看起来像这样:</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230224103802980.png" alt="image-20230224103802980"></p><p><strong>资源 John Smith 显示为一个椭圆</strong>，由**统一资源标识符 (URI) **标识，在本例中为 <strong>“http:&#x2F;&#x2F;…&#x2F;JohnSmith”</strong>。如果你不熟悉URI，可以简单地认为它们是看起来很奇怪的名称。</p><p>资源是有<strong>属性</strong>的。在这些例子中，我们感兴趣的是出现在 John Smith 的名片上的属性类型。图中只显示了一个属性，John Smith 的全名。</p><p><strong>属性由一个弧表示，用属性的名称标记</strong>。属性的名称也是一个URI。由于URI相当长且笨重，因此<strong>图中以 XML qname 形式</strong>显示了它。**<code>: </code>之前的部分 （vcard）<strong>称为</strong>命名空间前缀<strong>，表示命名空间。</strong><code>: </code>后面的部分（FN）<strong>称为</strong>本地名称**，表示该命名空间中的名称。当写成 RDF XML 时，属性通常以这种 qname 形式表示，这是在图表和文本中表示它们的方便快捷方式。但是严格来说，属性是通过URI标识的。nsprefix:localname 形式是命名空间的 URI 与 localname 连接的缩写。在浏览器访问属性时，并不要求将其 URI 解析为任何值。</p><p>每个属性都有一个值。在这个例子中，这个值是一个<strong>字面量</strong>，可以认为它是一个由<strong>字符</strong>组成的字符串。字面量以<strong>矩形</strong>表示。</p><p>Jena是一个Java API，可以用来创建和操作类似于这个的RDF图。Jena有对象类来表示图、资源、属性和字面量。表示资源、属性和字面量的接口分别称为资源（Resource）、属性（Property ）和字面量（Literal ）。在Jena中，图称为模型，由模型接口表示。</p><p>创建这个图或模型的代码很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// some definitions</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">personURI</span>    <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://somewhere/JohnSmith&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">fullName</span>     <span class="hljs-operator">=</span> <span class="hljs-string">&quot;John Smith&quot;</span>;<br><br><span class="hljs-comment">// create an empty Model</span><br><span class="hljs-type">Model</span> <span class="hljs-variable">model</span> <span class="hljs-operator">=</span> ModelFactory.createDefaultModel();<br><br><span class="hljs-comment">// create the resource</span><br><span class="hljs-type">Resource</span> <span class="hljs-variable">johnSmith</span> <span class="hljs-operator">=</span> model.createResource(personURI);<br><br><span class="hljs-comment">// add the property</span><br>johnSmith.addProperty(VCARD.FN, fullName);<br></code></pre></td></tr></table></figure><p>上述代码从常量定义开始，然后使用 <code>ModelFactory</code> 的方法 <code>createDefaultModel()</code> 在内存中创建一个空模型。Jena 包含 Model 接口的其他实现，例如使用关系数据库的实现：这些类型的模型也可以从 ModelFactory 中获得。</p><p>然后创建 John Smith 资源并向其添加属性。该属性由一个“常量（constant）”类 VCARD 提供，该类持有表示 VCARD 模式中所有定义的对象。Jena 为其他著名的模式提供了常量类，例如 RDF 和 RDF 模式本身、Dublin Core和OWL。</p><p>这个示例的代码可以在教程1中Jena发行版的&#x2F;src-examples目录中找到。作为练习，获取并修改这段代码，为自己创建一个简单的VCARD。</p><p>创建资源和添加属性的代码可以用层叠样式编写得更简洁:</p><h2 id="韩老师意见总结："><a href="#韩老师意见总结：" class="headerlink" title="韩老师意见总结："></a>韩老师意见总结：</h2><ol><li><strong>整体页面：</strong>大量的白色背景可能造成视觉疲劳，可以选择一些中性灰色作为背景，也能提升其他颜色的识别度；</li><li><strong>左侧查询输入框：</strong>下拉提示栏应该更宽，让提示词显示完整；</li><li><strong>Schema 图：</strong><ul><li>节点的双线高亮样式可能过于明显，影响了节点中间的文字，样式有待进一步修改；</li><li>展开节点时，一次性产生大量节点可能造成识别的困难。可以进一步做出区分（透明度等形式，展现强弱次序），加快用户认知速度；</li></ul></li><li><strong>右侧树形列表：</strong>可以与 Schema 图的节点颜色进行匹配，提升用户识别效率，辅助用户认知；</li></ol><p>数据：</p><p>交互：左侧搜索栏，节点下拉详情</p><p>样式：背景板样式、右侧搜索栏样式</p><p>，节点样式、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resource</span> <span class="hljs-variable">johnSmith</span> <span class="hljs-operator">=</span><br>      model.createResource(personURI)<br>           .addProperty(VCARD.FN, fullName);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Apache</tag>
      
      <tag>Jena</tag>
      
      <tag>RDF</tag>
      
      <tag>Sparql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端笔记 异步编程</title>
    <link href="/2023/02/15/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/02/15/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h2><p>进程（工厂）：可以理解为程序运行的环境，程序需要在内存中开辟一部分空间，存储代码、数据等内容</p><p>线程（工人）：是实际进行运算的部分，</p><h2 id="二、同步问题"><a href="#二、同步问题" class="headerlink" title="二、同步问题"></a>二、同步问题</h2><p>通常情况下代码都是<strong>同步执行</strong>的，即<strong>自上而下逐行执行</strong>。</p><p>如以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;嘿嘿&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;嘻嘻&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出应该为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">哈哈<br>嘿嘿<br>嘻嘻<br></code></pre></td></tr></table></figure><p>同步情况下，如果<strong>前一条代码没有执行完，后面的代码也不会执行</strong></p><p>如果该条代码非常耗时（设计网络请求、IO等内容的操作），会导致后续代码被<strong>阻塞</strong></p><p>即<strong>“一行代码执行缓慢”</strong>会影响整个程序的执行</p><h2 id="三、其他语言的解决办法（Java、Python）——-多线程"><a href="#三、其他语言的解决办法（Java、Python）——-多线程" class="headerlink" title="三、其他语言的解决办法（Java、Python）—— 多线程"></a>三、其他语言的解决办法（Java、Python）—— 多线程</h2><p>同步问题在 Java、Python 中是通过多线程的方式来解决的；</p><p>将高耗时的任务放在单独的线程中执行，其他任务不受影响；</p><p>但多线程会带来更高的性能开销，对服务器性能要求更高；</p><p>同时，对编写程序的要求也更高，程序需要针对多线程进行优化。</p><h2 id="四、Node-js-的解决方法-——-异步"><a href="#四、Node-js-的解决方法-——-异步" class="headerlink" title="四、Node.js 的解决方法 —— 异步"></a>四、Node.js 的解决方法 —— 异步</h2><p><strong>异步</strong>是指，<strong>一段代码的执行不会影响其他代码的执行</strong></p><p>这样就能让高耗时的任务不阻塞后续代码</p><p>如 setTimeout() 函数就是异步代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;, <span class="hljs-number">10000</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;111&quot;</span>)<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">sum</span>(<span class="hljs-number">111</span>, <span class="hljs-number">222</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;222&quot;</span>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 输出：</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 111</span><br><span class="hljs-comment">* undefined</span><br><span class="hljs-comment">* 222</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>可以看到 “222” 的输出并未被阻塞，但 result 也变为了 undefined，这是因为在输出 result 时，函数还未能返回值</p><p>这也就引出了异步的一个问题，<strong>异步函数无法通过 return 的方式来直接返回结果</strong></p><h2 id="五、通过回调函数返回结果"><a href="#五、通过回调函数返回结果" class="headerlink" title="五、通过回调函数返回结果"></a>五、通过回调函数返回结果</h2><p>为了解决这一问题，可以采用<strong>回调函数</strong>的方法，在使用需要异步代码的结果时，在获取到结果后调用回调函数来获取：</p><p>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b, callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(a + b);<br>&#125;, <span class="hljs-number">10000</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;111&quot;</span>)<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">sum</span>(<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;222&quot;</span>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 输出：</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 111</span><br><span class="hljs-comment">* 222</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 十秒后</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 333 </span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>回调函数的方法看似解决了异步问题，但如果这一函数被反复使用，会形成如下情况：</p><p>如在执行 111 +  222 后，还需将结果再加上 333</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">sum</span>(<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">333</span>, <span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>就会形成如上图所示的回调函数嵌套的情况，如果需要继续使用，就会不断嵌套：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">sum</span>(<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">333</span>, <span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">444</span>, <span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">555</span>, <span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">666</span>, <span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>        ......<br>    &#125;<br>    &#125;<br>    &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>由于每次执行新的异步代码，都需要在之前的异步代码的回调函数中书写</p><p>导致<strong>代码书写非常繁杂</strong>，<strong>代码可读性非常差</strong>，<strong>代码难以调试</strong>，被称之为<strong>“回调地狱”</strong></p><h2 id="六、Promise-解决异步问题"><a href="#六、Promise-解决异步问题" class="headerlink" title="六、Promise 解决异步问题"></a>六、Promise 解决异步问题</h2><p>Promise 是一个用于存储数据的容器，存取数据的方式比较特殊，使得 Promise 可以存储异步调用的数据</p><p>创建 Promise：</p><p>可以使用构造函数来创建，且构造函数中需要一个函数作为参数</p><p>这个函数会在<strong>创建 Promise 时调用，调用时会传入两个参数，分别为 resolve 和 reject</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve 和 reject 也是函数，通过这两个函数向 Promise 中存储数据</span><br>    <span class="hljs-comment">// resolve 在执行正常时存储数据，reject 在执行错误时存储数据</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;成功&quot;</span>)<br>    &#125;,<span class="hljs-number">2000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在读取数据时，可以<strong>通过 Promise 的实例方法 then() 来读取</strong></p><p>也需要两个回调函数作为参数，来获取 Promise 中的数据</p><p><strong>第一个函数获取 resolve 返回的数据（正常数据）</strong>，<strong>第二个获取 reject 返回的数据（异常数据）</strong></p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(result)</span>=&gt;</span>&#123;<br>console.log(result)<br>&#125;, <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">error</span>)</span>=&gt;</span>&#123;<br>console.log(result)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="七、Promise-原理"><a href="#七、Promise-原理" class="headerlink" title="七、Promise 原理"></a>七、Promise 原理</h2><p><strong>异步的真正难点不在于获取异步数据，而在于获取异步数据的时机</strong>，因为我们难以预测异步代码执行需要多久</p><p>为了解决这一问题，Promise中维护了两个隐藏属性：</p><p><strong>PromiseResult</strong> - 用于存储数据</p><p><strong>PromiseState</strong> - 用于记录 Promise 状态，分为三种：</p><pre><code class="hljs">- **fulfilled** 完成 - 通过 resolve 存储数据时，切换为这个状态- **rejected** 拒绝\出错 - 通过 reject 存储数据 ，切换为这个状态- **pending** 进行中 - 初始状态</code></pre><p><strong>PromiseState 只能修改一次</strong>，<strong>且修改后永远不会改变</strong></p><p>这两个属性设置为私有属性，也是为了保证数据不被篡改</p><p>Promise 的详细流程如下：</p><ul><li>Promise 创建时，PromiseState 初始值为 pending<ul><li>当通过 resolve 存储时，PromiseState 切换为 fulfilled，PromiseResult 变为存储的数据</li><li>当通过 reject 存储或出错时，PromiseState 切换为 rejected，PromiseResult 变为存储的数据或异常信息</li></ul></li><li>当通过 then 读取数据时，相当于为 Promise 设置了回调函数<ul><li>当 PromiseState 为 fulfilled 时，调用 then 的第一个回调函数来返回</li><li>当 PromiseState 为 rejected 时，调用 then 的第二个回调函数来返回</li></ul></li></ul><p>Promise还设置了 <strong>catch() 方法</strong>，用于异常处理</p><p>catch() 与 then 类似，但只需要一个回调函数，这个回调函数只会在 rejected 时才会调用</p><p>catch() 相当于 then(null, reason &#x3D;&gt;{ })</p><p>Promise 还设置了 <strong>finally() 方法</strong>，无论是正常获取还是异常，都会执行</p><p>但 finally 的回调函数是无参的，不会接收到数据，用于执行无论成功与否都要执行的代码</p>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>Sync</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读06 RDF Explorer</title>
    <link href="/2022/12/31/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB06-RDF-Explorer/"/>
    <url>/2022/12/31/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB06-RDF-Explorer/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221231200743192.png" alt="image-20221231200743192"></p><p><strong>摘要：</strong>用于管理大规模多源数据的知识图谱越来越受欢迎，希望对此类图谱提出富有表现力的查询的用户通常期望知道 (i) 如何用 SPARQL 等语言制定查询，以及 (ii) 感兴趣的实体如何在图中描述。本文提出了一种可以放松这些期望的语言：该语言的操作符是基于交互式图的探索，允许非专家用户同时导航和查询知识图；本文将这种语言的表达能力与 SPARQL 进行比较。然后讨论这种语言的实现，称之为RDF ExeLoRER，并讨论它所具有的各种理想属性，例如避免导致空结果的交互。通过对 Wikidata 知识图谱的用户研究，本文发现用户使用 RDF ExPLoRER 比使用现有的 Wikidata Query Helper成功地完成了更多的任务，而可用性调查问卷显示用户普遍更喜欢本文的工具，并且报告了较低的自我挫败感和脑力劳动水平。</p><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>在过去的十年中，数百个数据集基于 Semantic Web 标准发布，涵盖了各种领域。这些数据集使用基于图的RDF数据模型进行描述。在 Semantic Web 社区之外，使用图来大规模建模和管理不同数据的想法也变得越来越流行，最近各种知识图的发布就是一个标志。其中一些知识图表是专有的，由谷歌、微软、苹果等公司内部维护；而另一些则通过网络向公众开放，由专门的国际社区维护，如 DBpedia、Wikidata 等。</p><p>许多专门用于图的查询语言随后被提出，包括用于 RDF 图的 SPARQL，用于属性图的 Cypher 等等。但是，使用这些语言查询图形可能具有挑战性。首先，要求用户具备此类查询语言及其操作符语义的技术知识。其次，图通常用于表示不同的数据，这些数据可能不对应于特定的领域特定的模式，这意味着用户可能不容易将他们正在查询的数据概念化，特别是对于与领域无关的知识图谱。尽管存在这些限制，DBpedia 和 Wikidata 的查询服务每天收到数百万次查询；虽然许多这样的查询来自“机器人”，但至少有数以万计的查询不是，这些统计数据表明，这些知识图谱能够为许多用户和应用程序查询图形的价值。</p><p>几个接口已经被提出，它们允许外行用户以不同的目标、重点和假设来可视化、搜索、浏览和查询知识图谱。这类界面采用的一些关键方法，包括关键字搜索、面浏览、基于图的浏览、查询构建、图摘要、可视化技术以及它们的组合。然而，一般来说，许多被提议的系统为了可用性和效率而牺牲了表现力——支持的操作符和交互类型，以及最终可以通过接口捕获的查询类型。例如，很少有人提出可以处理具有周期的图形模式的接口，例如找到一起执导电影的兄弟姐妹，对合并症的一对表明或禁止使用的药物，相同分类的双星对，等等。能够捕获这种图形模式的接口通常需要具备一些查询语言方面的技术专长或数据建模方面的知识。</p><p>本文的工作提出了一种语言和相关的接口，使外行用户能够在知识图上构建和执行图模式查询，用户在其中导航子图的可视化表示，并在这样做的时候，增量地构建一个潜在复杂的(循环的)图模式。更具体地说，我们首先提出了一组操作符，形成了一种语言，允许用户通过交互式地探索 RDF 图来构建 SPARQL 图模式;我们进一步研究这种语言的表达能力。然后，我们讨论围绕该语言的用户界面设计，以及它所包含的用于提高可用性的附加实用功能，例如自动补全、结果预览、泛化示例等;我们将进一步描述如何在现有查询服务（SPARQL端点）之上实现该接口。本文主张是，与支持类似表达能力的现有接口相比，生成的接口允许外行用户更好地表达知识图上的图模式查询。为了评估这一说法，我们提出了一个基于任务的用户研究，比较我们的界面与 Wikidata 查询助手的可用性；结果表明，用户使用本系统完成任务的成功率较高。</p><p>相关工作部分略</p><h2 id="二、RDF-Explorer"><a href="#二、RDF-Explorer" class="headerlink" title="二、RDF Explorer"></a>二、RDF Explorer</h2><p>本节中介绍 RDF Explorer系统，其目标是使非专业用户能够查询和探索RDF图。首先讨论构成可视化查询语言基础的操作符，用户可以通过简单的交互来表达对图形的查询；描述了与SPARQL相关的语言的表达性。随后，我们将讨论 RDF Explorer 接口如何支持这种查询语言，以及整个系统是如何实现的。</p><h3 id="2-1-可视化查询图"><a href="#2-1-可视化查询图" class="headerlink" title="2.1 可视化查询图"></a>2.1 可视化查询图</h3><p>可视化查询语言是根据可视化查询图制定的。让 I 表示 IRIs 的集合，L 表示字面量的集合，V 表示查询变量的集合。定义可视化查询图如下所示：</p><p><strong>定义1</strong>：一个可视化查询图 (VQG) 被定义为一个有向的、有边标记的图 G &#x3D; (N, E)，节点集合为 N，边集合为 E。VQG 的点是一个有限的 IRIs、文字或变量的集合 : $ N \subset I \cup L \cup V$。VQG 的边是一个有限的三元组集合，其中每个三元组表示两个节点之间的有向边，其标签来自 IRIs 或变量集: $E \subset N \times (I \cup N) \times N $。</p><p>用 var(G) 表示出现在 G &#x3D; (N, E) 中的变量集，作为节点或边标签: $ var(G):&#x3D; {v \in V \ | \ v \in N \ or \ \exists \ n_1, n_2: (n_1, v, n_2) \in E } $。</p><p>我们说 VQG 是通过可视化查询语言构造的，由四个代数运算符组成，它们将与原子用户交互相对应：添加一个变量节点、添加一个常数节点、在两个具有变量标签的现有节点之间添加一条边，以及在两个具有IRI标签的现有节点之间添加一条边。更具体地说，VQG最初是空的：$G_0 &#x3D; (\empty, \empty)$。此后，可以通过可视化查询语言 (VQL) 构造 VQG，定义如下。</p><p><strong>定义2</strong>：设 G &#x3D; (N, E) 为当前 VQG；可视化查询语言 (VQL) 是通过以下四个原子操作定义的:</p><ul><li><p>初始化一个新的变量节点：$ \eta(G) :&#x3D; (N \cup { v } , E)$，其中 $ v \notin var(G)$</p></li><li><p>添加一个新的常数节点：$ \eta(G, x) :&#x3D; (N \cup { v } , E)$，其中 $ x \in (I \cup L)$</p></li><li><p>用边标签变量初始化两个节点之间的新边：</p><p>$ \epsilon(G, n_1, n_2) :&#x3D; (N, E \cup { n_1, v, n_2 })$，其中 $ { n_1, n_2 } \subseteq N, v \notin var(G)$</p></li><li><p>在两个具有 IRI 边标签的节点之间添加一条新边：</p><p>$ \epsilon(G, n_1, x, n_2) :&#x3D; (N, E \cup { n_1, x, n_2 })$，其中 $ { n_1, n_2 } \subseteq N, x \in I$</p></li></ul><p>注意，对于VQL操作符 $ \eta(G) $ 和 $ \epsilon(G, n_1, n_2) $，没有指定变量，可以自动生成任意的新变量。无论选择什么变量，由于添加的变量总是新的，因此得到的VQG 将是唯一的；在实践中，系统可以为每个变量生成新的名称。</p><p>尽管 VQG 是一种针对图表示查询的直接方法，但由于 VQG 允许表示循环，因此它们已经超出了许多图用户界面的表现力(实体搜索、方面等)，甚至超出了文献中提出的许多基于树的相关可视化查询语言的表现力。我们选择不支持超出简单图形模式的查询操作符，这些图形模式由类似的基于图形的接口所覆盖，如 NIGHTLIGHT 和RDF-GL，它们支持联合，可选等——因为我们认为这样的系统是针对具有一些查询语言知识的用户，不知道以一种外行用户可以访问的方式来表示这些操作符的直观方法。另一方面，VQG 将被转换为具体的 SPARQL 语法，更专业的用户可以根据需要修改结果查询。</p><h3 id="2-2-将-VQGs-翻译为-SPARQL"><a href="#2-2-将-VQGs-翻译为-SPARQL" class="headerlink" title="2.2 将 VQGs 翻译为 SPARQL"></a>2.2 将 VQGs 翻译为 SPARQL</h3><p>VQGs 被设计为 SPARQL 基本图模式 (BGPs) 的视觉隐喻，因此这里的翻译是最直接和自然的；然而，有些 BGPs 不能被表示为 VQGs ，而且，VQGs 的一些次要方面不能被翻译为 BGPs。在讨论这些问题之前，我们必须首先介绍 RDF 和 SPARQL  BGPs 的一些符号。</p><p>RDF三元组使用来自 IRIs (I)、字面量 (L) 和空白节点 (B) 集合的术语；更具体地说，一个三元组 t &#x3D; (s, p, o) 是一个 RDF 三元组 iff $ s \in I \cup B $ (称为主语)，$ p \in I$ (称为谓词) 和 $ o \in I \cup B \cup L $ (称为对象)。有限的 RDF 三元组集合称为 RDF 图。</p><p>SPARQL 基本图模式 (BGPs) 对应于 RDF 图，但其中也可以使用变量术语(V)。沿着这些线，一个三元组 q &#x3D; (s, p, o)是一个具有 $ s \in I \cup L \cup V, p \in I \cup V $ 以及 $ o \in I \cup L \cup V $ 的SPARQL 三元组。一个 SPARQL BGP 是一个有限的 SPARQL 三元组模式集。BGP 的语义是根据它对 RDF 图的评估定义的，该图返回一组映射。映射 $\mu : V \rightarrow (I \cup B \cup L) $ 是从变量到 RDF 术语的部分映射；定义的变量集称为 $\mu$ 的定义域，记为 $dom(\mu)$。给定一个查询 Q，我们用 var(Q) 表示它提到的变量集;此外，我们用 $\mu(q)$ 表示Q在p下的图像；用 $\mu(v)$ 替换 Q 中每个变量 $ v \in var(Q)$ 的每一次出现(或 v 如果 $v \notin dom(v)$ )的结果。BGP Q相对于 RDF 图 G 的评估，表示为 Q(G)，然后定义为映射的集合{p dom(μ) var(Q)和μ(Q) C G)(注意，这等价于-但比-将BGP的评估定义为其组成三重模式评估的连接)。</p><p>在将VQG转换为BGP方面，给定一个VQG G (N, E)，我们观察到，根据设计，集合E已经是一个BGP，我们就完成了。然而，首先我们必须指出，这种转换对孤节点(在G中没有事件边的节点)是不可知的;例如，G和n(G)将给出相同的BGP。其次，虽然vqg是具有等效定义的bgp，但并非所有vqg &#x2F; bgp都可以由前面描述的可视化查询语言中的四个操作符构造。特别是，我们不能在有连接变量的地方构造vqg &#x2F; bgp-一个变量出现在多个边&#x2F;三重模式中-作为边标签&#x2F;谓词出现(因为(N)操作仅为新变量定义，而(G, ni, z, N)仅在z为常量时定义);我们不认为这在实践中是一个重要的限制，因为对现实世界的SPArQ查询日志的分析表明，谓词位置上的连接很少。</p><p>然后可以用具体的SPARQL语法序列化VQG:对应的基本图形模式被写成SPARQL查询的WHERE子句，其中所有变量都用sELEcT *投影;此时，更专业的用户可能希望修改查询，例如添加查询操作符。</p><p>关于复杂性，我们注意到评估决策问题——它要求:给定映射u，查询Q和RDF图G，p是Q(G)吗?VQG生成的查询对于这个问题是容易处理的，因为它们不具有投影(一个简单的上限是由O(ll-lGl) 26]给出的)。然而，在界面中，我们实现了许多可用性特性，其中一个这样的特性是建议变量的可能基础，不会导致非空结果。这个自动补全特性对应的决策问题是，给定μ(where dom(u) var(Q))，一个查询Q和一个RDF图G， μ(Q)(G)非空吗?由于(Q)(G)可以表示一个图，并且可以从图同态问题中简化，因此该问题在组合复杂度上(考虑输入中G和Q的大小)是np完备的;然而，在数据复杂度方面(考虑查询Q是固定的)，这个问题是可以处理的。总之，随着vG变得更加复杂，自动补全任务可能变得具有挑战性;目前，我们依赖SPARQL查询来生成这些建议，我们将进一步优化留到将来的工作中。</p><h3 id="2-3-RDF-Explorer-界面"><a href="#2-3-RDF-Explorer-界面" class="headerlink" title="2.3 RDF Explorer 界面"></a>2.3 RDF Explorer 界面</h3><p>虽然可视化查询图为基本图形模式提供了可视化的隐喻，并且可视化查询语言描述了交互，通过这些交互，用户可以增量地构建可视化查询图，但这些概念留下了许多关于可用性的问题。例如，一个关键问题是VQG应该如何可视化。我们忽略的另一个实际问题是，虽然n(G)和(G, ni, n)不需要任何特定的知识(在后者中，用户可以选择可视化中显示的两个节点，例如，操作n(G, x)和(G, ni, n2，)需要用户给出一个特定的(IRI或文字)术语r，这假设了领域知识。此外，我们还没有解决Bhowmick等人讨论过的可用性特性，比如基于erample的查询、动作感知的查询处理，或者动态结果搜索和可视化。解决这些问题是实现我们的目标的关键，我们的目标是让外行用户在图上表达查询。沿着这些思路，我们现在描述RDF Explorer接口，我们建议用它来解决这些问题。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221231212008838.png" alt="RDF Explorer 界面示例1：可视化查询一起执导过电影的兄弟姐妹"></p><p>RDF Explorer接口由六个主要组件组成，显示在三个窗格中。图1提供了查询Wikidata界面的截图，其中我们可以看到三个组件:搜索面板(左窗格)、可视化查询编辑器(中心窗格)和节点详细信息视图(右窗格);右上角是用于切换右边窗格的按钮，以显示另外三个组件之一:节点编辑器(允许向突出显示的节点添加限制)、SPARQL查询编辑器(显示当前查询)和帮助面板。</p><p>该过程从一个空白的可视化查询编辑器开始。然后，用户必须添加一个新节点，无论是变量节点(n(G))还是常量节点(n(G, z));对于选择r，用户可以在左侧的搜索窗格中键入关键字短语，这将生成自动建议，其中显示的任何结果都可以拖到中央查询编辑器窗格中。然后，用户可以通过相同的方法继续添加第二个节点。如果有两个或多个节点可用，用户现在可以在两个节点之间单击和拖动，以生成带有变量边缘标签的边(显示为源节点内嵌套的框);潜在员工名单将建议IRIs替换变量，其中只提供为底层查询生成非空结果的IRIs。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221231212159540.png" alt="RDF Explorer 界面示例2：查询出生在奥克兰的政治家"></p><p>图2说明了该接口的其他一些特性。遵循属性图中使用的约定3]，我们在给定节点中显示数据类型属性以避免混乱;这可以从图2中的number of children属性中看到。在任何时候，用户都可以单击某个节点来查看进一步的详细信息:如果该节点是变量(参见图1)，他们将看到该变量的当前结果示例(通过将当前VQG映射到SPARQL并投影该变量而生成);如果节点是常量(参见图2)，则将显示该节点可用的数据，这些数据由数据类型属性(接受文字值)和对象属性(接受IRI值)组织。通过这种方式，根据Bhowmick等人[1o]的讨论，用户可以探索该图，并收到迄今为止生成的结果的反馈，指导下一步。常数节点可以转换为变量节点，使用户可以从一个特定的例子开始，然后泛化图14]。我们声称这些特性为非专业用户提高了系统的可用性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>KnowledgeGraph</tag>
      
      <tag>Visual query language</tag>
      
      <tag>Bidirectional transformation</tag>
      
      <tag>Query graph pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读08 KG4Vis A Knowledge Graph-Based Approach for Visualization Recommendation</title>
    <link href="/2022/12/31/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB08-KG4Vis/"/>
    <url>/2022/12/31/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB08-KG4Vis/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230402211923363.png" alt="image-20230402211923363"></p><p>摘要：可视化推荐或自动化的可视化生成可以显著地减低一般人快速制作高效数据可视化的障碍，特别是对那些没有数据可视化背景的人来说。然而，现有的基于规则的方法需要可视化专家对可视化规则进行繁杂的手动说明，而其他的基于机器学习的方法通常像黑盒一样并且很难理解为什么要推荐某种特定的可视化方法，这限制了这些方法的进一步推广。这篇论文通过推出“KG4Vis”填补了这一领域的空缺，一个基于知识图谱（KG）的可视化推荐方法。他不需要对可视化规则进行手动说明，也能保证很好的可解释性。特别地，我们推出了一个用于构建知识图谱的框架，由三类实体和他们之间的关系组成（如：数据特征，数据列，可视化设计选择），以建立数据和有效的可视化之间的映射法则。一个基于 TransE 的嵌入技术被部署用于从现有 数据-可视化对 中学习知识图谱中实体和关系的嵌入，这种嵌入本质上建模了可取的可视化规则。之后，对于给定的新数据集，可以带有语义上有意义的规则的知识图谱中推断出高效的可视化方法。我们对所提出的方法进行了广泛的评估，包括定量比较、案例研究和专家访谈。实验结果证明了该方法的有效性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge Graph</tag>
      
      <tag>Data Visualization</tag>
      
      <tag>Visualization recommendation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读07 RDF Shape Induction using Konwledge Base</title>
    <link href="/2022/12/31/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB07-RDF-Shape/"/>
    <url>/2022/12/31/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB07-RDF-Shape/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230114174948122.png" alt="image-20230114174948122"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>知识图谱 (KGs) 正在成为大多数人工智能和认知应用的核心。流行的 KG (如DBpedia和Wikidata) 已经选择RDF数据模型来表示它们的数据。</p><p>尽管具有这些优势，但在使用 RDF 数据时仍然存在挑战，例如数据验证。用于在 RDF 数据中指定领域概念化的<strong>本体是为蕴含而不是验证而设计的</strong>。<strong>大多数本体缺乏验证约束所需的粒度信息</strong>。</p><p>最近在 RDF 形状和诸如 SHACL 和 ShEX 等语言标准化方面的工作为表示 RDF 数据的完整性约束提供了更好的机制。</p><p>然而，手动为大型 KG 创建约束仍然是一项繁琐的任务。在本文中，我们提出了一种数据驱动的方法，用于使用数据分析为 RDF 数据引入完整性约束。这些约束可以组合成 RDF 形状，并可用于验证 RDF 图。<strong>我们的方法基于机器学习技术，使用概要 RDF 数据作为特征自动生成 RDF 形状。</strong>在实验中，提出的方法在为 DBpedia 数据子集推导带有基数约束的 RDF 形状时达到了 97% 的精度。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>知识图谱 (KGs) 正在成为大多数由领域知识驱动的人工智能应用程序的核心。流行的 KG (如DBpedia、YAGO2和Wikidata) 都选择了 RDF 数据模型来表示知识。RDF 是一种基于图的数据模型，它是语义 Web 和关联数据应用程序中的事实上的模型。RDF 图可以使用本体以语义丰富的方式捕获和表示领域信息。</p><p>与任何其他数据模型一样，为了指定 RDF 图必须满足的条件，需要施加约束。在实际设置中，约束通常用于三个主要任务:</p><p>(a) 指定数据应该持有的属性;</p><p>(b) 处理数据内部的矛盾或与考虑中的领域有关的矛盾;</p><p>(c) 作为查询优化的帮助。</p><p>本体语言设计用于使用已知公理推断新知识，而不是基于公理验证数据。推理器和验证器具有不同的功能，即推理器用于推断新知识，而验证器用于发现违反一组约束的情况。OWL中使用的基础原则，例如使用开放世界假设 (OWA) 和非唯一名称假设，可能会导致验证器中出现意想不到的结果。</p><p>因此，使用这些语言执行某些验证任务是很有挑战性的。在大多数传统的数据存储和发布范式中，对预定义模式进行验证是关键步骤之一; 例如，SQL 数据库中的 DDL 约束或 XML 模式或 XML 文档[27]中的RelaxNG 验证。对于 RDF 数据，通常使用基于 OWL 或 RDF Schema 的本体来进行这种验证。</p><p>然而，使用本体验证 RDF 数据会导致几个问题:</p><p>(a) 预期目的、推断(本体设计的目的)和验证之间的不匹配；</p><p>(b) 在大多数本体中缺乏对验证有用的信息。</p><p>一般来说，数据质量仍然是获得用户信任的一个关键方面。数据质量与给定上下文中“适合使用”的感知有关[32]。约束是包含在数据上的限制，这些数据应该一直由数据库[2]的实例满足。它们对用户理解数据很有用，因为它们代表了数据自然表现出的特征[22]。数据概要被定义为“为数据库创建小型但有信息的摘要的活动”[17]。<strong>在这项研究中，我们提出了一种数据驱动的方法，将机器学习技术应用于概要 RDF 数据，以自动生成完整性约束。</strong></p><p>然后，将与特定类相关的一组约束组合在一起，以约束集合的形式生成 RDF Shape。这些 RDF 形状可用于验证 RDF 图。</p><p><strong>从数据生成 RDF 形状的主要用例之一是质量评估。</strong>在这项工作中，我们使用DBpedia [21](版本201604) 作为我们的目标知识库，并尝试评估 DBpedia 知识库中所有 dbo:Person 实例的质量。这种质量评估的主要需求是确定每个人实例应该遵守的验证规则。例如，一个人的 “dbo:birthDate” 属性应该只有一个值，或者 “dbo:height” 属性的值应该总是一个正数。Person类的实例有超过13000个相关属性(包括 dbo、DBpedia 本体属性和 dbp，从 Wikipedia 信息框键自动生成的属性)。</p><p>因此，手动生成此类验证规则是一项繁琐、耗时且容易出错的任务。一些验证规则可以编码到本体中，但是仍然需要大量的手工工作。这项工作提出了一种方法，通过分析数据并使用归纳方法提取这些规则，以 RDF 形状的形式引入此类验证规则。诱导形状的其他用例包括描述数据(这有助于生成查询或创建动态用户界面)。</p><p>本文的主要贡献是<strong>一种基于使用机器学习算法诱导约束并使用数据概要信息作为特征生成RDF形状的新方法</strong>。所提出的方法以适用于任何类型约束的通用方式定义，并使用两种常见约束类型进行验证:</p><p>(a)基数约束;</p><p>(b)范围约束约束。</p><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>如果知识图谱不包含冲突或矛盾的数据[16]，则将其定义为<strong>一致的</strong>。当模式具有数据应该遵守的完整性约束时，数据通常会经过验证过程，根据这些约束验证遵从性。</p><p>这些完整性约束封装了数据的一致性要求，以便适合给定的用例集。例如，在关系数据库中，完整性约束用数据定义语言 (DDL) 表示，数据库管理系统 (DBMS) 确保插入到数据库中的任何数据不会导致整个数据库中的任何不一致。</p><p>然而，RDF数据的验证不是以这种方式进行的，原因有几个，比如缺乏表达约束的语言 (RDFS 和 OWL 是为包含而设计的，而不是像介绍中讨论的那样为验证而设计的)，或者具有适合更广泛使用而不适合特定用例的通用模型。</p><p>当本体中有定义领域概念化的 TBox 公理时，推理机可以通过验证本体中定义的公理来验证数据集是否与领域一致。然而，<strong>大多数本体并没有丰富的公理来帮助检测数据中的不一致性</strong>。</p><p>大多数大型知识库(如 DBpedia )缺乏完整性约束的定义，手动从头开始创建这些约束定义是一项繁琐的任务。此外，RDF 数据的大多数模式信息只能以最适合包含而不是验证的 OWL 本体的形式提供。然而，大多数使用RDF数据的实际用例需要根据完整性约束进行验证</p><p>近年来，W3C 社区通过 RDF 数据形状工作组 (RDF data Shapes Working Group) 和后来的形状表达式社区组 (Shape Expression community Group) 努力标准化一种语言，用于描述RDF实例数据的结构完整性约束和验证规则。这些努力的结果是 <strong>W3C 形状约束语言 (SHACL)</strong>[19] 和<strong>形状表达式语言</strong>[26]等语言，它们允许为RDF数据定义完整性约束并验证数据。</p><p>然而，对于像 DBpedia 这样包含超过 750 个类和 60,000 个属性 (dbo:和dbp:) 的大型 RDF 知识库，手动生成完整性约束仍然是一个挑战。在这种情况下，<strong>本文解决的主要研究问题是:如何为 RDF 数据自动生成完整性约束</strong></p><p>在这项研究中，我们提出了一种数据驱动的方法，<strong>通过将机器学习技术应用于从数据集中提取的 RDF 数据分析信息，为给定的数据集自动生成 RDF 形状</strong></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>使用从统计数据分析器中提取的信息，我们的目标是为给定数据集中的数据生成有代表性的 RDF shape。我们在类级别生成形状。示例摘录了SHACL中用于 dbo:Person 类的 RDF Shape 在清单1中。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230116132530822.png" alt="image-20230116132530822"></p><p>为此，人们开发了大量专门用于解决此类基于约束的挖掘和学习问题的系统和技术 [10]。约束既可以用于描述性设置，如发现关联规则[3]，也可以用于预测性设置，如规则学习[13]。</p><p>本文的关键贡献在于，我们研究了如何将剖面图数据应用于RDF形状归纳，据我们所知，还没有针对 RDF 数据验证问题进行处理。</p><p>我们的主要假设是，机器学习技术可以通过使用数据分析信息作为特征来生成正确的 RDF 形状。在第4节中，我们定义了一种生成 RDF 形状的方法，并通过评估生成的 RD F形状来验证我们的假设，以确保所定义的约束是准确的 (使用手动标记的测试数据)。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>本体学习 (OL) 通常被定义为一个包含从数据中自动获取本体知识的技术的领域。因此，范式已经发生了变化，许多方法不再旨在从数据中生成一个完整的、完美标准的本体，而是专注于获取某些形状的公理，如概念定义、原子包容、脱节公理。关于描述逻辑公理的归纳，有一些工作是使用方法完成的，例如: ARM、PGM、SRL、ILP 等。</p><p>我们的最终目标与这些研究方法不同。我们的目标不是引入本体论公理，而是引入验证规则。近年来，基于表达约束引入了各种 RDF 验证语言。</p><p>Web 本体语言[23]是一种基于描述逻辑 (DL) 的表达本体语言。OWL的语义解决了分布式知识表示场景，在这种场景下，不能假设对领域有完整的知识。为了解决上述不匹配问题，一些方法使用带有封闭世界假设和弱唯一名称假设的 OWL 表达式，这样 OWL 表达式就可以用于验证目的。</p><p>W3C 形状约束语言(SHACL)[19]用于根据一组条件验证 RDF 图。这些条件以 RDF 图的形式表示为形状和其他构造。特别是，它有助于通过使用 SPARQL 识别约束。此外，它还提供了高级词汇表来标识谓词及其相关基数和数据类型。</p><p>形状表达式 (ShEx)[26] 语言描述 RDF 节点和图结构。节点约束描述 RDF 节点 (IRI、空白节点或文字)，形状描述 RDF 图中涉及节点的三元组。这些描述标识谓词及其相关基数和数据类型。</p><p>SPARQL推断符号(SPIN)约束将RDF类型或节点与验证规则相关联。特别地，SPIN允许用户使用SPARQL指定规则和逻辑约束。</p><p>这些形状表达式语言，即 ShEx、SHACL和SPIN，旨在验证 RDF 数据并在用户之间通信数据语义。它们涵盖了诸如键和基数等约束; 然而，它们的表达能力是有限的，并且需要用户干预。</p><p>在我们的方法中，我们的目标是使用机器学习将形状生成过程自动化。更具体地说，可以根据关系模型中的成功程度在 RDF 中设想各种约束，例如基数约束和范围约束。Neuman 和 Merkotte 提出了“特征集”，用于对具有多个连接[25]的 RDF 查询执行基数估计。这些工作与本文的工作在两个轴上有所不同。首先，它们专注于确定每个值的基数，而不是实体-值关系的基数。其次，它们关注查询优化，而不是完整性约束验证。然而，我们利用这些工作的基础，如均值、方差和其他统计特征的分析，导出了完整性约束验证的基数估计方法。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>如上所述，RDF 形状可以帮助验证现有的知识图谱;然而，手动完成这是一项乏味的任务。因此，为解决自动生成 RDF 形状的挑战，提出一种基于数据 profiling 的 RDF 形状归纳工作流。我们定义了一个通用的工作流，这样它就可以应用于任何类型的约束。我们为两种类型的约束提供了示例，即基数约束和范围约束。类似地，它可以扩展到其他类型的约束，如值范围约束(min和max值)，字符串约束(minLength, maxLength, pattern, languesin, uniqueLanguage)，或属性对约束(lessThan, lessThanOrEquals, disjoint, equal)。工作流的目标是通过分析数据模式和统计数据来提取约束，并将提取的约束组合起来生成可用于验证的 RDF                               形状。所提议的工作流的主要步骤如图1所示。工作流的输入是来自Loupe[24]的统计分析信息，这是一个用于分析 RDF 数据的工具。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230116132736512.png" alt="image-20230116132736512"></p><h3 id="任务制定"><a href="#任务制定" class="headerlink" title="任务制定"></a>任务制定</h3><p>工作流的第一步是作为典型的机器学习任务制定特定的约束提取目标。基数约束:对于基数约束，我们的目标是在相关时生成两个基数约束，即最小基数和最大基数。</p><p>作为更好地理解任务的第一步，我们收集了预期的基数(Le。3cixty知识库[33]中的215个属性子集和西班牙国家图书馆(BNE)数据集的166个属性子集。在分析数据集时，我们发现两个数据集中只有少数重复的共同模式。表1显示了我们在黄金标准中发现的常见基数模式。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230116135358131.png" alt="image-20230116135358131"></p><p>我们可以在显式表达基数约束的词汇表中观察到同样的趋势。当我们分析链接开放词汇表(LOV)目录中的551个词汇的基数限制值时，猫头鹰:maxCardinality约束的96.91%(875个中的848个)的值为1，猫头鹰:minCardinality约束的93.76%(673个中的631个)的值为0或1。</p><p>因此，在我们的工作中，我们不是试图估计最小基数值和最大基数值的确切数字，而是查找每个属性相对于给定类具有哪个基数类别。通过这样做，我们将问题从回归问题减少到分类问题。</p><p>范围限制:对于范围限制，我们的目标是双重的。首先，我们希望为与给定类关联的每个属性生成一个对象节点类型约束。我们使用SHACL中已经确定的节点类型的子集，即IRI、Literal、BlankNode和BlankNodeOrIRI。一旦确定了节点类型，就必须确定更具体的范围约束。如果节点类型是Literal，则必须确定相应的数据类型。如果节点类型是IRI、BlankNode或BlankNodeOrIRI，则必须确定对象的类类型。</p><p>我们把这个任务也定义为一个分类问题。我们将与给定类的实例关联的每个属性分类为前面提到的节点类型之一。第二项任务是根据数据类型或类类型在与属性关联的对象集中的分布情况，将相应的数据类型或类分配为每个属性的范围。</p><h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><p>基数约束:Loupe提供基数信息对于与给定类的实例相关联的每个属性。例如，通过分析DBpedia中的1,767,272个dbo:Person实例，Loupe提取dbo:Person-dbo:deathDate组合的基数分布，如表2所示。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230116135631570.png" alt="image-20230116135631570"></p><p>在特征工程步骤中，这些原始分析数据用于派生一组可用于预测基数的特征。具体来说，我们从这些数据中推导出了30个特征，包括最小-最大基数、均值、模态、标准差、方差和其他与分布相关的指标。完整的名单可以在这里找到5。范围约束:Loupe为与给定类的实例相关联的每个属性提供了关于IRIs、文字和空白节点数量的统计信息，如表3所示。空节点计数也由Loupe生成，但没有显示在表中，因为本例中没有空节点。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230116135659286.png" alt="image-20230116135659286"></p><p>此外，Loupe还通过分析所有IRI和空白节点对象提取对象类型信息。类的所有对象进行分析，表4通过分析dbo:Person-dbp:deathPlace类属性组合的所有对象显示了对象类型信息的示例。它包含对象的数量、每种类类型的不同对象的数量以及它们各自的百分比。可以看到，dbo:Person-dbp:deathPlace的对象使用许多不同的类进行类型化。事实上，大多数对象都是用多个类(例如，等价类、超类)来类型化的。还有一些对象不应该被关联(例如。例如，使用dbp:deathPlace属性，广播器不应该是一个人的死亡地点。此外，还有一些对象的类型信息不可用。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230116135709373.png" alt="image-20230116135709373"></p><p>类似地，对于文字对象，Loupe提取关于其数据类型的信息。表5显示了类-属性组合dbp:Person-dbp:deathDate的提取信息示例。对于每种数据类型，它显示了对象的数量、不同对象的数量以及它们相应的百分比。这些信息提供了关于哪些应该是相应的数据类型的启发。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230116135729387.png" alt="image-20230116135729387"></p><p>我们使用上述所有信息作为两个任务的特征:检测对象节点类型，检测IRI对象的类类型和文字对象的数据类型。</p><h3 id="算法选择"><a href="#算法选择" class="headerlink" title="算法选择"></a>算法选择</h3><p>在算法选择步骤中，目标是为第一步中确定的每个任务选择最合适的算法。由于我们已经将基数预测和范围预测任务都表述为分类问题，因此我们将以通用的方式描述算法选择步骤。</p><p>为了选择算法，我们将该模型的准确性视为所有预测中正确预测的数量。在经典的机器学习方法中，它被称为分类精度。但是，在训练中运行算法。不同超参数设置的数据集将产生不同的模型[6]。我们特别感兴趣的是选择性能最好的模型。我们使用分类器的准确性来评估各种模型的预测性能。具体而言，评估模型预测性能的步骤如下:</p><p>(1)我们希望通过调整学习算法并从给定的假设空间中选择性能最佳的模型来提高分类器的准确性。在我们的概要数据集中，我们观察到在选择约束作为响应变量的情况下，两个变量之间的变化小于15%，很少会发生事件。我们应用SMOTE (Synthetic Minority oversampling Technique)[9]对罕见事件进行过采样。SMOTE函数通过使用自举和k-最近邻对响应变量进行过度采样，以综合创建该响应变量的额外观测值。</p><p>(2)为了减少准确性分数的方差，我们需要确保每个实例用于训练的次数相等。我们应用了k倍交叉验证，其中k是在数据集中进行分割的次数。在这种方法中，我们选择k&#x3D;10的值。这导致将数据集分成10部分(10次折叠)并运行算法10次。</p><p>(3)在预测建模问题上建立基线性能是很重要的。在实验分析中，我们采用了ZeroR分类方法。ZeroR是一个平凡的分类器，但它给出了给定数据集性能的下界，这应该通过更复杂的分类器得到显著改善。因此，这是一个合理的测试，可以在不考虑其他属性[34]的情况下预测类的好坏。</p><p>(4)最后，为了确定最适合手头问题的机器学习算法，我们对所选算法进行了比较。我们从6类机器学习方法中选择了9种算法。基于分类器精度的最大值，我们从假设空间中选择了性能最好的模型。</p><h3 id="约束生成"><a href="#约束生成" class="headerlink" title="约束生成"></a>约束生成</h3><p>一旦建立了约束预测模型，就可以生成约束。基数约束:在基数约束的分类任务中，我们确定了五种主要类型的基数类:MINO、MIN1、MIN1+、MAX1、MAX1+。除此之外，MINO和MAX1+没有对数据施加任何约束，这样，任何数据对于这些基数类型都是有效的。因此，如果检测到这些类型，就不会生成约束。对于其他类型，生成相应的SHACL属性约束，如清单2所示。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230116135929097.png" alt="image-20230116135929097"></p><p>范围约束:对于范围约束，我们生成两种类型的约束。首先，如果与给定类关联的属性的对象是IRI、Literal、BlankNode和BlankNodeOrIRL，则生成这些节点类型约束如清单3所示。然后，我们为IRI对象生成类类型约束，为文字对象生成数据类型约束。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20230116140002988.png" alt="image-20230116140002988"></p><h3 id="形状生成"><a href="#形状生成" class="headerlink" title="形状生成"></a>形状生成</h3><p>最后一步的目标是组合与给定类相关的所有约束，并为该类生成RDF Shape。在前面的步骤中，为每个类属性组合生成了约束;例如， foaf:name 与 dbo:Person 类关联时的基数约束。类似地，约束生成到与 dbo:Person 类实例关联的所有属性。给定类的所有这些约束组合在一起以生成类的形状。</p><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><p>基于我们方法的基数约束，我们在 DBpedia 和 3cixty 两个 KBs 上进行了实验分析。</p><p>有趣的是，在给定类的情况下看到基数约束，以及属性，即有多少对象链接到一个主题。如果我们基于属性所表示的关系来考虑主体和对象，我们可以考虑实体-关系(ER)模型所使用的不同基数模式，例如一对一(1-1)、一对多(1-N)、多对一(N-1)和多对多(N-N)。</p><p>因此，我们将基数预测任务定义为一个分类问题。这个实验分析的目标是评估我们的方法在多少正确的预测做出的背景下。特别地，我们将基数分类器的性能与基线精度进行比较。更具体地说，在KB图中应用机器学习的核心问题之一是转换和识别特征，同时保留其中包含的信息的微妙之处。我们的目标是验证两个基数约束的预测，即基于黄金标准的概要数据的最小和最大基数。</p><p>在这个实验中，我们创建了一个黄金标准，由四个人工注释人员标记数据。批注员互相修改批注，如果没有达成一致意见，就请第三个批注员。对于DBpedia，我们为174个属性的子集创建了期望基数的黄金标准。类似地，对于3cixty，我们为215个属性的子集创建了一个。特别是，收集到的数据集为DBpedia的174个属性和3cixty的215个属性提供了与给定类的实例相关联的每个属性的基数信息。</p><p>数据集可以在线访问。我们通过将数据集分成10个部分，对算法部分任务进行10倍交叉验证。对于每个算法训练，它将在90%的数据上运行，并在10%的数据上进行测试。特别地，它将每个数据实例作为训练实例使用9次，每个测试实例使用1次。我们的方法已经实现了一个用R语言编写的原型。</p>]]></content>
    
    
    
    <tags>
      
      <tag>KnowledgeGraph</tag>
      
      <tag>Visual query language</tag>
      
      <tag>Bidirectional transformation</tag>
      
      <tag>Query graph pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读05 KGVQL</title>
    <link href="/2022/11/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB05-KGVQL/"/>
    <url>/2022/11/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB05-KGVQL/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221117192419468.png" alt="image-20221117192419468"></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>随着知识图谱技术的发展，设计能够支持高效查询的查询语言成为了一个至关重要的研究课题，主要面临如下挑战：</p><ul><li><strong>易用性：</strong>像 SPARQL 和 Cypher 这类查询语言，虽然有丰富的语义，但由于其为专业人员设计，语法较为复杂。因此可能对不具备KG或查询语言专业知识的最终用户不友好</li><li><strong>普遍性：</strong>文本查询语言对于一般用户难以使用，而现有的许多交互可视化查询语言都与某一类型的知识图谱绑定。对于不同种类的知识图谱，用户需要学习不同的查询方法，增加了学习成本</li><li><strong>导航支持：</strong>现有查询语言无法在用户查询知识图谱时获得从查询结果到查询图的导航，更无法提供查询图到相应查询结果的双向转换轨迹。从问题到相应查询结果的过程示例如下图所示。视觉语言中的黑色箭头对应文本语言，而视觉语言中的红色箭头对应探索过程。</li></ul><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221117195950043.png" alt="从查询到结果的过程"></p><p>​</p><p>综上所述，现有的知识图查询语言，无论是 SPARQL 还是 Cypher，都需要用户具备专业知识，因此使用起来有一定困难。因此，有必要提出一种交互式可视化知识图查询系统来解决上述问题，该系统应独立于任何特定的知识图或查询语言，并可适应于诸如 RDF 图的 SPARQL 和属性图的 Cypher 或 Gremlin 等。</p><p>为此，本文提出了一种知识图可视化查询语言KGVQL，本文工作可以总结如下：</p><ul><li>提出了一种支持多运算符（如UNION, OPT, FILTER和LIMIT）的知识图交互式可视化查询语言 KGVQL，并且独立于特定的底层图查询语言</li><li>KGVQL 首次实现了查询图和查询结果之间双向转换的工作。它可以在用户探索知识图时提供查询结果的中间结果和轨迹，有效指导最终用户逐级构建查询图。</li><li>开发了一个交互式可视化查询界面 KGVQL，并通过实验证明其在帮助终端用户在速度和准确性方面查询和理解知识图方面的有用性。</li></ul><h1 id="KGVQL-语言"><a href="#KGVQL-语言" class="headerlink" title="KGVQL 语言"></a>KGVQL 语言</h1><p>在本节中给出了与常见知识图查询意图相对应的五个用例。描述了KGVQL的可视化语法、到SPARQL语法片段的映射、构成查询和结果之间的轨迹的一般图以及双向转换的过程。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221119111530679.png" alt="Common use cases"></p><p>如上表所示，KGVQL 从相关工作和 DBpedia 基准中确定了五个常见用例（U1–U5），这些用例被视为 KGVQL 设计的实际背景。</p><p>U1–U5的组合涵盖各种知识图查询：U1 和 U2 分别按关键字和类型查询实体；U3 查询实体之间的关系；U4 限制从查询中获得的结果，即 FILTER 和 LIMIT；U5 涉及对各种运算符（即 UNION 和 OPT）的复杂查询。</p><p>可以确定交互式可视化查询语言和系统的设计需求如下：</p><p>（1） 查询结果应该被可视化地显示，且由于对大规模知识图谱的查询可能产生相当大的查询结果，因此需要最大限度地利用用户界面上的可用空间；</p><p>（2） 为了支持对大型知识图谱中包含的信息的访问，用户应该能够自由浏览知识图谱并轻松找到他们需要的信息；</p><p>（3） 此外，并非所有查询结果都直接满足用户的查询意图。在图谱浏览过程中，可能有一些用户感兴趣的节点。为了将查询结果与这些节点区分开来，KGVQL 突出显示了从表达用户查询意图的查询图中直接获得的查询结果。</p><h2 id="KGVQL-基础元素"><a href="#KGVQL-基础元素" class="headerlink" title="KGVQL 基础元素"></a>KGVQL 基础元素</h2><p>在不缺失通用性的前提下，KGVQL 可视化语法的设计基于 SPARQL 查询模式。</p><p>KGVQL 可视化查询的<strong>基本单元是由有向边连接的圆</strong>组成的查询图模式，用于表示知识图上的一般图匹配查询。</p><p>在此基础上，KGVQL通过使用<strong>具有不同操作符类型的双圆</strong>来支持各种操作符，从而将基本的查询图模式扩展为复杂的查询图模式。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221119110709161.png" alt="The basic elements of KGVQL"></p><p>如上表所示，几个基本元素被用来表示 KGVQL 的可视化语法：</p><p>(1) 实体元素 (E)，实心圆表示知识图中的实体 (常量或变量);</p><p>(2) 关系元素 (R)，有向实箭头表示实体之间的关系 (常量’p’或变量’?p’);</p><p>(3) 操作符元素 (OP)，双圆表示操作符 (操作’C’，例如UNION, LIMIT);</p><p>(4) 参数值元 (PV)，表示参数的矩形;</p><p>(5) 投影实体和投影关系元素 (PE 和 PR)，虚线和箭头分别表示在查询结果中要投影的实体或关系。</p><p>知识图谱以实体和关系元素组成的有向图的形式给出。</p><p><strong>定义1(知识图谱)：</strong>知识图谱 G &#x3D; (E, R) 是一个有向图，其中 E 是实体元素的有限集，R 是连接实体元素的关系元素的有限集。</p><h2 id="KGVQL-可视化语法"><a href="#KGVQL-可视化语法" class="headerlink" title="KGVQL 可视化语法"></a>KGVQL 可视化语法</h2><p>KGVQL 的可视化语法是由基本元素组成的图模式表示的，也称为查询图模式，可以由基本元素递归地构造。</p><p><strong>定义2：</strong>KGVQL查询图模式P的递归定义及可视化构造如下</p><ol><li><p>**(单元查询图模式)**：由元素 $s,o \in S_E$ 和 $ p \in Sp$ 组成的图模式，p 在图形上与 s 和 o相连，这是一种查询图模式，其中 $ S_E$ 是实体元素 (E) 和投影实体元素 (PE) 的有限集， $S_P$ 是关系元素 (R) 和投影关系元素 (PR) 的有限集。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221119113124401.png" alt="image-20221119113124401"></p></li><li><p>**(基本查询图模式)**：由多个查询图模式组成的图模式，这些查询图模式包含共同的实体，并由这些实体连接起来，这就是基本查询图模式。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221119113144300.png" alt="image-20221119113144300"></p></li><li><p>**(受限查询图模式)**：如果 P 是一个查询图模式，那么带有操作符元素 $c \in S_C$ 和参数值元素 $v \in S_V$ 的 P 也是一个查询图模式，其中 $S_C$ 是操作符元素的有限集(OP，即 LIMIT 或 FILTER)， $ S_V$ 是参数值元素(PV)的有限集。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221119113158542.png" alt="image-20221119113158542"></p></li><li><p>**(组合图查询模式)**：由查询图模式 $P_1$ 组成的图模式，通过操作符元素 $c \in S_C$ 连接到查询图模式 $P_2$，是一个查询图模式，其中 $S_C$ 是操作符元素的有限集(OP，即 UNION 或 OPT)。 $P_1$ 的投影实体和投影关系集，应与 $P_2$ 的投影实体和投影关系集一致</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221119113209812.png" alt="image-20221119113209812"></p></li></ol><p><strong>单元查询图模式</strong>是 KGVQL 最基本的查询图模式，它相当于知识图中的三元模式</p><p><strong>基本查询图模式</strong>可根据其共同的实体元素递归分解为多个单元查询图模式</p><p><strong>受限查询图模式</strong>通过操作符元素(即LIMIT或FILTER)和参数值元素限制查询结果</p><p><strong>组合查询图模式</strong>中，操作符元素UNION或OPT组合P1和P2，即(P1 UNION P2)和(P1 OPT P2)。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221119113319692.png" alt="Examples of visual syntax in KGVQL"></p><p>KGVQL 基于由图模式表示的查询，上表显示了使用KGVQL语法表示的查询图模式的各种情况。</p><p>给定查询图模式 P 和知识图谱 G，将 P 对 G 的结果记为查询结果 [P]c。操作符元素 (OP) 用于组合查询图模式或限制查询结果。参数值元素 (PV) 用作操作的参数，例如 FILTER 或 LIMIT。对于 FILTER，参数值是边和节点属性的约束，它们是由不等式符号 (&lt;，&gt;，&lt;，&gt;) 和方程符号 (&#x3D;) 组成的术语的布尔组合。对于 LIMIT，参数值是一个常数。</p><h2 id="作为-SPARQL-片段的-KGVQL"><a href="#作为-SPARQL-片段的-KGVQL" class="headerlink" title="作为 SPARQL 片段的 KGVQL"></a>作为 SPARQL 片段的 KGVQL</h2><p>在 KGVQL 中，最终用户不需要学习特定的文本查询语言。通过 QBE，用户只需要在给定的界面上使用必要的图形元素并填写一些必填字段，就可以执行查询并获得相应的结果。</p><p>为了说明KGVQL语法的通用性，本节将介绍一个与 KGVQL 支持的查询特性等价的 SPARQL 语法片段，并通过示例展示 KGVQL 与 SPARQL 之间的映射，即KGVQL在SPARQL中的实现。</p><p>值得注意的是，SPARQL 使用<strong>词查询模式</strong>，而 KGVQL 使用<strong>词查询图模式</strong>。</p><p>让无限的成对不相交集合 $I$ 和 $L$ 表示知识图谱 RDF 数据模型中的 $URIs$ 和字面量。$T&#x3D;(I \cup L)$是 RDF 术语的集合，RDF 图是 RDF 三元组 $(s, p, o) \in I \times I \times T$ 的有限集合，其中s、p、o分别表示知识图谱中事实的主语、谓语和对象。</p><p>关于 KGVQL与 SPARQL 之间映射部分不进一步详细记录。</p><h2 id="一般图模式"><a href="#一般图模式" class="headerlink" title="一般图模式"></a>一般图模式</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221119114904521.png" alt="The transformation process from a query result to a query graph."></p>]]></content>
    
    
    
    <tags>
      
      <tag>KnowledgeGraph</tag>
      
      <tag>Visual query language</tag>
      
      <tag>Bidirectional transformation</tag>
      
      <tag>Query graph pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读04 知识图谱可视化查询技术综述</title>
    <link href="/2022/11/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB04-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/"/>
    <url>/2022/11/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB04-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221110181547061.png" alt="image-20221110181547061"></p><p>当前知识图谱可视化及可视化查询工作可以分为三个方面：</p><ul><li>基于已有可视技术对知识图谱的可视化表示：用于<strong>辅助用户理解</strong>知识图谱</li><li>大规模知识图谱的可视化查询语言及查询系统：针对<strong>大规模数据</strong>的理解、<strong>查询</strong>和分析</li><li>知识图谱间的联合可视化查询分析：<strong>跨数据集</strong>的联合查询</li></ul><h1 id="1-知识图谱可视化"><a href="#1-知识图谱可视化" class="headerlink" title="1 知识图谱可视化"></a>1 知识图谱可视化</h1><h2 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h2><p>多为一般图模型 $ G &#x3D; (V, E)$ 的扩展形式：</p><p><strong>RDF 图：</strong>有限个 $(s, p, o)$ 三元组的集合，$s$ 代表主语，$p$ 代表谓语，$o$ 代表宾语；</p><p><strong>属性图：</strong>相较于一般图模型，为顶点和边增加了属性（键值对形式）；</p><p><strong>有向标签图：</strong>相较于一般图模型，顶点增加标签，属于特殊的 RDF 图；</p><p><strong>异构信息网络图：</strong>相较于一般图模型，为顶点和边增加了一个对象或链接类型，类型总数超过1则可称作异构信息网络。</p><h2 id="1-2-可视表达"><a href="#1-2-可视表达" class="headerlink" title="1.2 可视表达"></a>1.2 可视表达</h2><p>基于<strong>节点-链接</strong>的可视技术：点或圆圈表示节点，边表示节点间链接，可利用颜色、半径等信息表示实体类型。此外还有根据胡克定律及库仑定律提出的力导向布局算法，通过赋予节点引力与斥力的方式让节点处于平衡状态，类似的模型还有 FR 模型、应力模型等。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112101913060.png" alt="节点-链接图示例"></p><p>基于<strong>邻接矩阵</strong>的可视技术：节点-链接的可视技术存在交叉重叠等难以避免的问题，而邻接矩阵可以有效规避此类问题，使数据更具备可读性。邻接矩阵图通过行列向量的交叉反应节点间关系，其可视化效果很大程度上受节点排序影响。邻接矩阵图缺点在于无法直观了解图的拓扑结构以及图中存在的隐含关系，不适用于路径匹配类的查询任务，在此基础上有混合布局邻接矩阵；结合桑基图、柱状图的多视图可视化系统；结合树的多变量图可视化系统等。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112101940632.png" alt="同一个图在不同节点排序下的邻接矩阵图"></p><p><strong>大规模</strong>知识图谱可视化技术：</p><p>目前已经有了大量公开发表的大规模知识图谱，如 <strong>WordNet</strong>、<strong>DBpedia</strong>、<strong>UnitProt</strong>、<strong>SciKG</strong>等，在这些数据集基础上，通过定义抽象层、不同布局模型等方式，可以构建相应的知识图谱可视化系统。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112101630079.png" alt="大规模知识图谱可视化一般步骤"></p><h1 id="2-可视化查询"><a href="#2-可视化查询" class="headerlink" title="2 可视化查询"></a>2 可视化查询</h1><p>由于知识图谱没有统一数据模型，对于不同数据模型的知识图谱需要使用不同的查询语言。</p><p><strong>SPARQL</strong>（SPARQL Protocol and RDF Query Language）是 W3C 制定的 RDF 知识图谱标准查询语言。</p><p><strong>Cypher</strong>（Neo4j）和 <strong>Gremlin</strong>（Apache TinkerPop）是在属性图上的查询语言。</p><p>此外还有按例查询的 <strong>Query By Example</strong>（QBE） 方法，无需用户进行专业学习和训练。</p><h2 id="2-1-知识图谱可视化查询语言"><a href="#2-1-知识图谱可视化查询语言" class="headerlink" title="2.1 知识图谱可视化查询语言"></a>2.1 知识图谱可视化查询语言</h2><h3 id="2-1-1-基于-RDF-图的可视化查询语言"><a href="#2-1-1-基于-RDF-图的可视化查询语言" class="headerlink" title="2.1.1 基于 RDF 图的可视化查询语言"></a>2.1.1 基于 RDF 图的可视化查询语言</h3><p><strong>RDF-GL：</strong>矩形和有向线段的组合构成基本查询模式，使用圆形表示 UNION、OPTIONAL运算符，将 COUNT、LIMIT 等操作符内置于矩形之中。不具备良好可学习性和可读性。</p><p><strong>QueryVOWL：</strong>基于 SPARQL 和 VOWL，通过圆圈和有向线段的组合形成复杂查询模式，用矩形表示 RDF 图中的字面量，圆圈中的数字表示 COUNT 的查询结果。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112103150289.png" alt="QueryVOWL"></p><p><strong>KGVis：</strong>将中检结果存储在查询模式中，实现查询模式与查询结果间的双向转换。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112103306377.png" alt="基于 KGVis 的可视化系统架构"></p><h3 id="2-2-2-基于属性图的可视化查询语言"><a href="#2-2-2-基于属性图的可视化查询语言" class="headerlink" title="2.2.2 基于属性图的可视化查询语言"></a>2.2.2 基于属性图的可视化查询语言</h3><p>属性图相较于 RDF 图在节点和边上内置了属性信息，在工业界广泛采用，但还未形成统一工业标准，近年来 LDBC 正在进行标准化工作。</p><p><strong>V1：</strong>通过矩形和线段组合表示属性图的基本图模式，用颜色区分节点类别。不基于任意一种图查询语言，采用算数与逻辑运算符 &amp;、||、X  而非采用某一特定查询语言中的 “AND” 等运算符。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112104224545.png" alt="V1"></p><h2 id="2-2-知识图谱可视化查询系统"><a href="#2-2-知识图谱可视化查询系统" class="headerlink" title="2.2 知识图谱可视化查询系统"></a>2.2 知识图谱可视化查询系统</h2><h3 id="2-2-1-基于关键字的可视化查询系统"><a href="#2-2-1-基于关键字的可视化查询系统" class="headerlink" title="2.2.1 基于关键字的可视化查询系统"></a>2.2.1 基于关键字的可视化查询系统</h3><p>与搜索引擎的关键字查询类似，只需用户输入关键字即可查询，但由于实体于实体间往往不止一种关系，基于关键字的可视化查询系统使用并不广泛。</p><p><strong>GQBE：</strong>以用户输入的实体元组作为关键字，计算实体元组构成的加权隐藏最大子图，通过计算查询结果与关键字的相似度对结果进行排序。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112105605030.png" alt="GQBE"></p><h3 id="2-2-2-基于过滤的可视化查询系统"><a href="#2-2-2-基于过滤的可视化查询系统" class="headerlink" title="2.2.2 基于过滤的可视化查询系统"></a>2.2.2 基于过滤的可视化查询系统</h3><p>通过不断过滤用户的筛选条件反复细化查询结果，通常以实体或类型作为查询起点，适用于星型查询模式。</p><p><strong>Grafa：</strong>预先查询并存储下一步查询结果，将不为空的关系或属性以选项的形式供用户进行选择。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112105639328.png" alt="Grafa"></p><h3 id="2-2-3-基于模板的可视化查询系统"><a href="#2-2-3-基于模板的可视化查询系统" class="headerlink" title="2.2.3 基于模板的可视化查询系统"></a>2.2.3 基于模板的可视化查询系统</h3><p>从 QBE 发展而来，不需要通过算法预测用户查询意图，也不同于基于过滤的查询方法只能支持简单星型查询。</p><p><strong>VISAGE：</strong>通过子图匹配查询将查询结果可视化给用户。</p><p><strong>VIGOR：</strong>在 VISAGE 基础上提出，在 DBLP 的共同作者知识图谱以及网络安全数据集上进行了实验。</p><p><strong>生物信息可视化查询：</strong>通过矩形和有向线段的组合表示查询模式，QD 代表一直实体，TD 代表希望查询的结果。</p><p><strong>ProvRPQ：</strong>交互式可视化正则路径查询工具。</p><p><strong>SPARQLVis：</strong>交互式可视化查询工具，支持关键字、过滤、正则路径查询。</p><p><strong>KG3D：</strong>运用 3D 可视化技术的交互式 3D 可视化工具。</p><h2 id="2-3-本体的可视化查询"><a href="#2-3-本体的可视化查询" class="headerlink" title="2.3 本体的可视化查询"></a>2.3 本体的可视化查询</h2><h3 id="2-3-1-基于层次结构的可视化查询"><a href="#2-3-1-基于层次结构的可视化查询" class="headerlink" title="2.3.1 基于层次结构的可视化查询"></a>2.3.1 基于层次结构的可视化查询</h3><p><strong>Protégé：</strong>基于 JAVA 语言开发的本体编辑和知识获取软件，针对本体层次结构可视化。属性图和欧拉图是体现层次结构最佳的可视化模型。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112120357879.png" alt="Protégé"></p><h3 id="2-3-1-基于非层次结构的可视化查询"><a href="#2-3-1-基于非层次结构的可视化查询" class="headerlink" title="2.3.1 基于非层次结构的可视化查询"></a>2.3.1 基于非层次结构的可视化查询</h3><p><strong>Onto Plot：</strong>采用并主图为主要可视化方法，在保留本体主要层次机构的同时，对查询结果中涉及不到的节点进行视觉压缩，查询结果基本处于同一层次的高度，从而实现大规模本体数据上单非层次关联查询。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112120541187.png" alt="Onto Plot"></p><h2 id="可视化查询技术对比总结"><a href="#可视化查询技术对比总结" class="headerlink" title="可视化查询技术对比总结"></a>可视化查询技术对比总结</h2><table><thead><tr><th>数据类型</th><th>可视化查询技术</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>知识图谱</td><td>基于 RDF 图的查询语言</td><td>有标准文本查询语言 SPARQL，有一定理论依据</td><td>不支持复杂图模式查询；可读性弱</td></tr><tr><td></td><td>基于属性图的查询语言</td><td>以逻辑运算为根本理论依据，表达力强</td><td>可学习性低</td></tr><tr><td></td><td>基于关键字的查询</td><td>用户无需输入完整问题；满足用户对知识图谱背景知识的需求</td><td>查询准确率低；不支持复杂图模式查询</td></tr><tr><td></td><td>基于过滤的查询</td><td>以关键字和类型进行查询；适用于星型查询和链式查询</td><td>不支持复杂图模式查询</td></tr><tr><td></td><td>基于模板的查询</td><td>有较高可用性和可学习性；满足用户对知识图谱背景知识的需求；可根据需求找到合适的模板，查询准确率高</td><td>需要不断完善模板；不支持其他类型查询</td></tr><tr><td>本体</td><td>基于层次结构的查询</td><td>能够有效展示本体数据中存在的层次关联；支持对多重继承复制概念</td><td>不支持非层次关联问题的查询</td></tr><tr><td></td><td>基于非层次结构的查询</td><td>支持对非层次关联问题的查询</td><td>不能保留本体中完整的层次结构；不能有效表达多重继承关系</td></tr></tbody></table><h1 id="3-领域知识图谱可视化查询"><a href="#3-领域知识图谱可视化查询" class="headerlink" title="3 领域知识图谱可视化查询"></a>3 领域知识图谱可视化查询</h1><p>通用的可视化查询方法不能有效地针对各个领域的特定问题进行描述，因此针对领域的知识图谱可视化查询成为一项重要挑战。</p><p>应用包括：学术知识图谱可视化、社交网络可视化、网络空间安全可视化、生物信息领域可视化、电商领域可视化、社会舆情可视分析、地理空间数据可视分析、电网运行状态可视分析等等</p><h1 id="4-未来研究方向"><a href="#4-未来研究方向" class="headerlink" title="4 未来研究方向"></a>4 未来研究方向</h1><ol><li>对已有的知识图谱数据模型设计统一的知识图谱可视化查询语言</li><li>将可视化前沿技术与知识图谱的数据模型结合，从而更好地展示知识图谱丰富的语义信息</li><li>对已有知识图谱可视化技术优化，以适配领域特定知识图谱可视化查询</li><li>针对大规模知识图谱数据，实现大规模知识图谱的高效可视化查询</li><li>针对知识图谱的领域特性，实现跨领域知识图谱间的联合可视化查询</li></ol>]]></content>
    
    
    <categories>
      
      <category>PaperReading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KnowledgeGraph</tag>
      
      <tag>Summarize</tag>
      
      <tag>qurey language</tag>
      
      <tag>visualization technology</tag>
      
      <tag>visualization query</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 原理及安装</title>
    <link href="/2022/11/08/Nginx-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E8%A3%85/"/>
    <url>/2022/11/08/Nginx-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="跨域问题："><a href="#跨域问题：" class="headerlink" title="跨域问题："></a>跨域问题：</h1><p>浏览器对于 js 的有同源策略的限制，例如 <a href="http://a.cn/">http://a.cn</a> 下的 js 不能调用 <a href="http://b.cn/">http://b.cn</a> 中的 js、对象或数据（因为 <a href="http://a.cn/">http://a.cn</a> 和  <a href="http://a.cn/">http://a.cn</a>  是不同域）</p><p>在做前后端完全分离的项目时，前端所有请求都发往后端，不会出现跨域问题。</p><p>但在前端直接向其他网站（包括统一域名的不同端口和不同协议）发送请求时就会产生跨域问题。</p><p>在 Vue 项目中，开发环境下解决跨域，常使用脚手架本身的 Proxy Server 来解决：</p><p>在 vue.config.js （Vue 2.x）中设置如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">dev</span>: &#123;<br>    <span class="hljs-attr">proxyTable</span>: &#123; <span class="hljs-comment">// 配置跨域</span><br>    <span class="hljs-string">&#x27;/api&#x27;</span>:&#123;<br>        <span class="hljs-attr">target</span>:<span class="hljs-string">`http://www.baidu.com`</span>, <span class="hljs-comment">//请求后台接口</span><br>        <span class="hljs-attr">changeOrigin</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">// 允许跨域</span><br>        <span class="hljs-attr">pathRewrite</span>:&#123;<br>            <span class="hljs-string">&#x27;^/api&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 重写请求</span><br>        &#125;<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>以如上代码为例，可以将所有以 &#x2F;api 开头的 http 请求代理转发到 target 中的地址，将请求开头的 &#x2F;api 转写为 <a href="http://www.baidu.com./">http://www.baidu.com。</a></p><p>其实际原理是开启一个代理转发服务器，将所有请求代理到当前端口，再在服务器内部转发请求，由于服务期间不存在跨域，就可以正常访问了。</p><p>但在生产环境下，Vue 不再提供代理转发服务器，需要自己解决跨域问题。</p><h1 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h1><p><a href="http://nginx.org/">NGINX</a> 是高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，因稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名。</p><p>其特点是占有内存少，并发能力强，事实上 NGINX的并发能力在同类型的网页服务器中表现较好，中国大陆使用 NGINX 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 </p><p>NGINX 处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。<br>NGINX 支持热部署，启动简单，可以做到7*24不间断运行。几个月都不需要重新启动。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112133655998.png" alt="image-20221112133655998"></p><p>正向代理：在本地搭建一个服务器来帮助访问（浏览器中配置代理服务器）</p><p>反向代理： 如：访问淘宝时，淘宝内部肯定不是只有一台服务器，它的内部有很多台服务器，那我们进行访问的时候，因为服务器中间 session 不共享，在服务器之间访问需要频繁登录，这时如果淘宝搭建一个过渡服务器，对客户来说是没有任何影响的，客户登录一次就可以访问所有服务器，这种情况就是反向代理。</p><p>对用户来说，客户端对代理是无感知的，客户端不需要任何配置就可以访问，我们只需要把请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器的地址。（在服务器中配置代理服务器）</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>现有的请求使服务器压力太大无法承受，需要搭建一个服务器集群，去分担原先一个服务器所承受的压力</p><p>当有多台服务器时，需要把请求分给这些服务器，但是服务器性能不同，如何分配请求，以使得不同性能的服务器得到最大程度的利用，就是负载均衡。</p><h3 id="Nginx-的三种负载均衡方式："><a href="#Nginx-的三种负载均衡方式：" class="headerlink" title="Nginx 的三种负载均衡方式："></a>Nginx 的三种负载均衡方式：</h3><p><strong>轮询法：</strong><br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>适合服务器配置相当，无状态且短平快的服务使用。也适用于图片服务器集群和纯静态页面服务器集群。<br><strong>加权轮询：</strong><br>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<br>这种方式比较灵活，当后端服务器性能存在差异的时候，通过配置权重，可以让服务器的性能得到充分发挥，有效利用资源。weight和访问比率成正比，用于后端服务器性能不均的情况。权重越高，被访问的概率越大。<br><strong>IP 哈希：</strong><br>上述方式存在一个问题：在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，请求可能会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失。<br>IP 哈希可以解决这个问题：如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。每个请求按访问 IP 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Windows下：访问 <a href="http://nginx.org/en/download.html">nginx: download</a> 下载稳定版压缩包，解压即可</p><p>进入 NGINX，输入 nginx.exe 回车即可启动（路径不能包含中文）</p><p>打开浏览器：浏览器地址栏输入网址 <a href="http://localhost/">http://localhost:80</a> 回车，出现以下页面说明启动成功</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221112134715523.png" alt="image-20221112134715523"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>通过修改 conf 文件夹下的 nginx.conf 文件来配置 nginx，每次改动后使用 <code>nginx -s reload</code> 即可让改动生效，无需重启 nginx；</p><p>关闭时使用 <code>nginx -s stop</code> 快速停止，或 <code>nginx -s quit</code> 安全停止。</p>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端笔记-React-入门</title>
    <link href="/2022/11/08/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-React-%E5%85%A5%E9%97%A8/"/>
    <url>/2022/11/08/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-React-%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="React-简介"><a href="#React-简介" class="headerlink" title="React 简介"></a>React 简介</h1><p>React 由 FaceBook 开发，是一个开源的用于构建用户界面的 JavaScript 库。React 还有  React Native 框架，通过它可以直接使用 JS 开发原生应用。</p><p><strong>React 的 特点如下：</strong></p><ul><li>虚拟 DOM （性能好，操作简单，兼容好）</li><li>声明式</li><li>基于组件</li><li>支持服务器端渲染</li><li>快速、简单、易学</li></ul><h1 id="React-Hello-World"><a href="#React-Hello-World" class="headerlink" title="React - Hello World"></a>React - Hello World</h1><p>React 是用来<strong>代替 DOM 的</strong>，那么首先来看传统的 Dom 操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 通过 dom 添加 div：</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 创建 div</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 向 div 中添加内容</span></span><br><span class="language-javascript">    div.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;这是div&quot;</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 获取 root</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 将 div 添加到 root 下</span></span><br><span class="language-javascript">    root.<span class="hljs-title function_">appendChild</span>(div)</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如使用 React：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <br>  <span class="hljs-comment">&lt;!-- 引入 react 核心库 和 dom 库 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;react-root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 通过 react 添加 div:</span></span><br><span class="language-javascript">    <span class="hljs-comment">// React.createElement() 方法，用于创建一个 React 元素</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 参数：</span></span><br><span class="language-javascript">    <span class="hljs-comment">//      1. 元素名（组件名）</span></span><br><span class="language-javascript">    <span class="hljs-comment">//      2. 元素中的属性（如：class、id）</span></span><br><span class="language-javascript">    <span class="hljs-comment">//      3. 元素的子元素（内容）</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> reactDiv = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;react hello world!&#x27;</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 获取根元素对应的 React 元素</span></span><br><span class="language-javascript">    <span class="hljs-comment">// ReactDOM.createRoot() 用来创建 React 根元素，需要一个 DOM 元素作为参数</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> rooter = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;react-root&quot;</span>))</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 将 div 渲染到 root</span></span><br><span class="language-javascript">    rooter.<span class="hljs-title function_">render</span>(reactDiv)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里用到了三个方法：<code>React.createElement()</code>、<code>ReactDOM.createRoot()</code>、<code>root.render()</code>，接下来进行一下详细分析：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>我是按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// React.createElement() 方法</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 参数：</span></span><br><span class="language-javascript">    <span class="hljs-comment">//      1. 元素名（html标签名必须小写，首字母如果大写会被认为是 Root）</span></span><br><span class="language-javascript">    <span class="hljs-comment">//      2. 标签中的属性</span></span><br><span class="language-javascript">    <span class="hljs-comment">//        - 设置事件时 - 属性名要用驼峰命名法，内容不要写成字符串代码，写成函数</span></span><br><span class="language-javascript">    <span class="hljs-comment">//        - class 属性用 className 来设置</span></span><br><span class="language-javascript">    <span class="hljs-comment">//      3. 元素的子元素（内容），之后的参数也被当做子元素加入</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 注意：</span></span><br><span class="language-javascript">    <span class="hljs-comment">//    - createElement 创建的是 React 元素，最终会通过虚拟 DOM 转化为真实 DOM（如果是 React Native，则会转为原生组件）</span></span><br><span class="language-javascript">    <span class="hljs-comment">//    - React 元素一旦创建就无法修改（dom 修改操作极其复杂，如果 React 也支持修改，会导致 API 和 dom 一样臃肿）</span></span><br><span class="language-javascript">    <span class="hljs-comment">//    - 要修改 React 元素，只能创建新元素替换，这样并不会导致过多性能损失，React会对比新旧对象，只替换更新的部分）</span></span><br><span class="language-javascript">    <span class="hljs-comment">//    - 修改 React 元素后，要调用 render 方法重新渲染</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> button = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>, &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;react-button&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;button&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">onClick</span>: <span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-number">1233</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;, <span class="hljs-string">&quot;按钮&quot;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> div = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;我是div&#x27;</span>, button)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// ReactDOM.createRoot() 方法 </span></span><br><span class="language-javascript">    <span class="hljs-comment">// 获取根元素</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 根元素是 React 元素要插入的位置</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>))</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// root.render() 方法</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 将 react 元素 div 渲染到根元素中，根元素中所有内容都会被 React 元素替换</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 重复调用 render() 时，React 会确保以最小的修改方式进行渲染，对 DOM 做最小的变化</span></span><br><span class="language-javascript">    root.<span class="hljs-title function_">render</span>(div)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      </span><br><span class="language-javascript">    <span class="hljs-comment">// 替换 React 元素示例（并非常规开发过程中使用的，仅作原理展示）：</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 获取按钮</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 绑定事件</span></span><br><span class="language-javascript">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> button = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;react-button&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;button&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">onClick</span>: <span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">          <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;按钮变了&#x27;</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;, <span class="hljs-string">&quot;按钮2&quot;</span>);</span><br><span class="language-javascript">      </span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> div = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;我是div&#x27;</span>, button)</span><br><span class="language-javascript">      </span><br><span class="language-javascript">      <span class="hljs-comment">// 根元素中的所有内容被删除，被 react 元素替换</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 重复调用 render() 时，会使用差分算法(diffing algorithm)比较变化，以最小的变化高效地修改 dom</span></span><br><span class="language-javascript">      root.<span class="hljs-title function_">render</span>(div)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="JSX-（JavaScript-Syntax-Extension）"><a href="#JSX-（JavaScript-Syntax-Extension）" class="headerlink" title="JSX （JavaScript Syntax Extension）"></a>JSX （JavaScript Syntax Extension）</h1><p>命令式编程：过程导向，告诉编译器，按照什么流程去执行命令：</p><p>如果使用上文提到的三个 API，只能以命令式编程的方式进行编程，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 命令式编程：</span><br><span class="hljs-comment">// 目的：创建一个 &lt;button&gt;按钮&lt;/button&gt;</span><br><span class="hljs-keyword">const</span> btn = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;按钮&#x27;</span>)<br></code></pre></td></tr></table></figure><p>声明式编程：结果导向，告诉编译器，要什么结果，过程交给框架去实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 声明式编程</span><br><span class="hljs-keyword">const</span> div = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>我是按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在 React 中，可以通过 JSX ，以类似 HTML 的方式来创建 React 元素，JSX 需要使用 babel 编译为 JS 代码，才能被 React 执行</p><h2 id="JSX注意事项"><a href="#JSX注意事项" class="headerlink" title="JSX注意事项"></a>JSX注意事项</h2><ol><li><p>JSX 不是字符串，不加引号</p></li><li><p>JSX 中 html 标签小写，React 组件大写开头</p></li><li><p>JSX 中有且仅有一个根标签</p></li><li><p>JSX 标签必须要正确结束（自结束标签必须写斜杠）</p></li><li><p>JSX 中可以使用 {} 嵌入表达式（有值的就是表达式）</p></li><li><p>如果表达式是空值（布尔、空、undefined） 不会显示、</p></li><li><p>在 JSX 中，属性可以直接在标签中设置（class 需要使用 className 设置； style 必须使用对象设置）</p></li></ol><h2 id="渲染列表"><a href="#渲染列表" class="headerlink" title="渲染列表"></a>渲染列表</h2><p>在 jsx 中，{} 内只能放表达式，而不能放 if 语句</p><p>但可以在 if 语句中操作 jsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Takuzen&#x27;</span><br><span class="hljs-keyword">const</span> lang = <span class="hljs-string">&#x27;en&#x27;</span><br><br><span class="hljs-keyword">let</span> div;<br><br><span class="hljs-keyword">if</span> (lang == <span class="hljs-string">&#x27;en&#x27;</span>)&#123;<br>  div = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> hello &#123;name&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lang == <span class="hljs-string">&#x27;cn&#x27;</span>)&#123;<br>  div = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 你好 &#123;name&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>))<br>root.<span class="hljs-title function_">render</span>(div)<br></code></pre></td></tr></table></figure><p>如果要将 array 在网页中渲染，不需要使用循环，jsx会自动将数组进行遍历，然后渲染</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&#x27;孙悟空&#x27;</span>, <span class="hljs-string">&#x27;猪八戒&#x27;</span>, <span class="hljs-string">&#x27;沙和尚&#x27;</span>]<br><br><span class="hljs-keyword">const</span> list = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> &#123;array&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如果要将 array 在网页中渲染为列表，可以将数组中的元素都包上 &lt;li&gt;&lt;&#x2F;li&gt;</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> data = [<span class="hljs-string">&#x27;孙悟空&#x27;</span>, <span class="hljs-string">&#x27;猪八戒&#x27;</span>, <span class="hljs-string">&#x27;沙和尚&#x27;</span>]<br><span class="hljs-keyword">const</span> array = []<br><br><span class="hljs-comment">// 遍历 data，变为列表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-property">length</span>; i++) &#123;<br>array.<span class="hljs-title function_">push</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;data[i]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>)<br>&#125;<br><br><span class="hljs-comment">// 或使用 map</span><br><span class="hljs-keyword">const</span> list = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span> &#123;array&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>))<br>root.<span class="hljs-title function_">render</span>(list)<br></code></pre></td></tr></table></figure><p>对数组遍历生成新数组的过程也可以使用 map() 方法实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> data = [<span class="hljs-string">&#x27;孙悟空&#x27;</span>, <span class="hljs-string">&#x27;猪八戒&#x27;</span>, <span class="hljs-string">&#x27;沙和尚&#x27;</span>]<br><br><span class="hljs-comment">// 使用 map 遍历</span><br><span class="hljs-comment">// map 方法返回的是值，在jsx中使用要加 &#123;&#125;</span><br><span class="hljs-comment">// item 是参数，在jsx中使用要加 &#123;&#125;</span><br><span class="hljs-keyword">const</span> list = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span> &#123;data.map(item =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>))<br>root.<span class="hljs-title function_">render</span>(list)<br></code></pre></td></tr></table></figure><h1 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h1><p>在 React 中操作的是 <code>React元素</code>，而非 <code>原生DOM</code> 元素</p><p>React 通过 <code>虚拟DOM</code> 将 <code>React元素</code> 和<code>原生DOM</code>进行映射，虽然操作的是 <code>React元素</code>，但这些操作最终会在 <code>原生DOM</code> 上 体现</p><p><code>虚拟DOM</code> 有以下好处</p><ol><li><p>降低 API 复杂度</p></li><li><p>解决兼容问题</p></li><li><p>提升性能（减少不必要的 DOM 操作）</p></li></ol><p>每当调用 <code>root.render()</code> 时，页面重新渲染：</p><ol><li>React 会通过 diffing 算法，将新的元素和旧的元素进行比较（自上而下逐层对比新旧元素，如果上层就不一样，直接修改，一样再继续往下层比较）</li><li>通过比较，React 找到发生变化的元素，并且只对变化的元素进行修改，没有变化的不予处理</li></ol><p>在 JSX 中显示数组，数组中每个元素都要设置一个唯一的 key，否则会显示警告，这是因为：</p><p>重新渲染页面时，React 会按照顺序依次比较元素，如果不指定 key，也按照顺序比较；</p><p>如果数组元素顺序没有变化，则没有影响，但如果列表顺序变化了，可能会导致性能问题（在最后添加没有影响，在开头添加可能导致全部重新渲染）；</p><p>开发时一般使用 id 作为 key，有些场景可以使用 index 作为 key（性能较差，和没用index 一样，只能消除警告）</p>]]></content>
    
    
    <categories>
      
      <category>Learn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FrontEnd</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构01-并查集</title>
    <link href="/2022/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集（Union-Find）"><a href="#并查集（Union-Find）" class="headerlink" title="并查集（Union-Find）"></a>并查集（Union-Find）</h1><h2 id="基本定义："><a href="#基本定义：" class="headerlink" title="基本定义："></a>基本定义：</h2><p>并查集是指：对集合有“并”和“查”两种操作的一种数据结构；（这里的集合可以理解为无向图）</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105213338279.png" alt="image-20221105213338279"></p><p>并操作：将两个节点连通；</p><p>查操作：两个节点是否是连通的；</p><h2 id="连通性："><a href="#连通性：" class="headerlink" title="连通性："></a><strong>连通性：</strong></h2><p><strong>自反性</strong>：p 与 q 连通 即 p 被与 q 连通</p><p><strong>对称性</strong>：p 与 q 连通，则 q 与 p 连通</p><p><strong>传递性</strong>：如果 p 连通 q，q 连通r，则 p 连通 r</p><h2 id="连通子图："><a href="#连通子图：" class="headerlink" title="连通子图："></a>连通子图：</h2><p>相互连通的最大集合，例：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105214300593.png" alt="image-20221105214300593"></p><h2 id="实现操作："><a href="#实现操作：" class="headerlink" title="实现操作："></a>实现操作：</h2><p>对于一个有 N 个节点的并查集，可能有 M 个“并”或“查”的操作混合使用，实现操作的目的是当 N 和 M 非常大的时候仍让保持”并“和”查“高效，</p><h3 id="思路1：快速查找"><a href="#思路1：快速查找" class="headerlink" title="思路1：快速查找"></a>思路1：快速查找</h3><p><strong>思路：</strong>使用大小为 N 的数组存储连通关系，当且仅当数组中的两个值相等时，其下标所指的节点是连通的；初始化时，每个节点的原始值即为本身；</p><p><strong>例：</strong></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105215053780.png" alt="image-20221105215053780"></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105215039652.png" alt="image-20221105215039652"></p><p>这种思路下，<strong>很容易进行查找操作</strong>，对于节点 i 和节点 j，只需要比较 id[i] 和 id[j] 的值，相等则连通，不相等则不连通，时间复杂度为 O(1)。</p><p>但在<strong>进行“并”操作时代价较高</strong>，如果要连接 p 节点和 q 节点，不仅需要将其将 q 点的值修改为 p 点的值，还需将所有与 q点 的值相等的节点的值都修改为 p 点的值，这需要对整个数组进行一次遍历，时间复杂度为 O(N)。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105215732878.png" alt="image-20221105215732878"></p><h3 id="思路2：快速合并"><a href="#思路2：快速合并" class="headerlink" title="思路2：快速合并"></a>思路2：快速合并</h3><p><strong>思路：</strong>这一思路采用树形结构来存储，同样使用大小为 N 的数组，但存储的是节点的父节点，初始化时，每个节点的原始值即为本身；</p><p><strong>例：</strong></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105220558868.png" alt="image-20221105220558868"></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105220611012.png" alt="image-20221105220611012"></p><p>这种思路下，<strong>很容易进行连接操作</strong>，对于节点 p 和节点 q，只需要将 q 的值修改为 p 的值（q的父节点为q）即可，时间复杂度为 O(1)；</p><p>但在<strong>进行“查找”操作时代价较高</strong>，要判断两节点是否连通，需要判断两节点是否有相同的“根”</p><p>如要比较 2 号 和 3 号节点，<strong>需要先找到 2 的根节点：</strong>2 的父节点是 9, 9 的父节点是 9 本身，所以 2 的根节点为 9；<strong>再寻找3的根节点：</strong>3 的父节点是 4, 4 的父节点是 9, 9 的父节点是 9 本身，所以 3 的根节点也为 9；因此两者是连通的。</p><p>在寻找时，需要逐层向上寻找父节点，最坏情况下，如果整个并查集是一个深度为 N 的树，则时间复杂度达到 O(N)</p><h3 id="改进思路1：加权快速合并"><a href="#改进思路1：加权快速合并" class="headerlink" title="改进思路1：加权快速合并"></a>改进思路1：加权快速合并</h3><p><strong>思路：</strong>快速合并的问题在于，树的深度过高会影响查找速度，那么可以通过优化树的高度来改进：</p><p>快速合并在进行连接操作时，如要将 p 和 q 连接，由于总是将 p 连接到 q，可能将<strong>更高的树</strong>的<strong>父节点</strong>设置为<strong>更矮的树</strong>，这使得树的高度被进一步增高；</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105222000514.png" alt="image-20221105222000514"></p><p>如果能够记录树的深度，每次连接时都能将<strong>更矮的树</strong>的<strong>父节点</strong>设置为<strong>更高的树</strong>，就能缩短树的高度。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105222514690.png" alt="image-20221105222514690"></p><p>在实现时，需要额外增加一个数组，用于记录根为 i 的树中的节点数目，增加了一定的空间开销（空间换时间）；</p><h3 id="改进思路2：路径压缩"><a href="#改进思路2：路径压缩" class="headerlink" title="改进思路2：路径压缩"></a>改进思路2：路径压缩</h3><p><strong>思路：</strong>仍然通过优化树的高度来改进：</p><p>路径压缩优化不在连接的时候进行，<strong>在查找操作时进行</strong>：当查询到某节点的根节点时，直接将节点的父节点设置为根节点，缩短了字树的高度，在<strong>下次查找时就能节省时间</strong>了；</p><p><strong>例：</strong>查询 9 的根节点时，需要逐层查询 9、6、3、1 的父节点，其根节点都为 0，则将这些点的,父节点都设置为 0</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105223637199.png" alt="image-20221105223637199"></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105223800468.png" alt="image-20221105223800468"></p><p>这一操作使得树变得“扁平”，且不增加时间复杂度（只需要一个额外的赋值操作）</p><h3 id="总结：时间复杂度分析"><a href="#总结：时间复杂度分析" class="headerlink" title="总结：时间复杂度分析"></a>总结：时间复杂度分析</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221105224224396.png" alt="image-20221105224224396"></p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
      <tag>UnionFind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形式语言与自动机04-NFA</title>
    <link href="/2022/09/15/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA04-NFA/"/>
    <url>/2022/09/15/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA04-NFA/</url>
    
    <content type="html"><![CDATA[<p>如果要构建一个在字母表 {0, 1}上的，接受以 101 为结尾的字符串的 DFA，答案如下：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221003162924197.png" alt="image-20221003162924197"></p><p>假设我们可以猜测我们正在读取的字符串何时只剩下3个符号，那么我们可以简单地寻找序列101，如果我们看到它就接受它</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221003163031244.png" alt="image-20221003163031244"></p><p>由于你无法确定什么时候字符串快要结束，这一自动不再具有确定性</p><p>这种非确定性是一种猜测的能力，我们可以稍后验证</p><p>以 101 结尾的字符串语言的非正式化的非确定性算法：</p><ol><li>猜测你是否接近输入的结束</li><li>如果猜测为是，寻找101并且当看到他的时候接受</li><li>如果猜测为否，再读入一个字符串并跳转到一步</li></ol><h2 id="非确定有限自动机-Nondeterministic-finite-automata"><a href="#非确定有限自动机-Nondeterministic-finite-automata" class="headerlink" title="非确定有限自动机 Nondeterministic finite automata"></a>非确定有限自动机 Nondeterministic finite automata</h2><p>这时一种允许你进行猜测的自动机，例如：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221003163616822.png" alt="image-20221003163616822"></p><ul><li>NFA 的每个状态可以有 0 个、1 个或多个用相同符号标记的跃迁</li><li>状态 $q_0$ 有两个标记为 1 的跃迁</li><li>当读到 1 时，我们可以选择保持 $q_0$ 还是移动到 $q_1$ </li><li>状态  $q_1$ 没有标记为 1 的跃迁</li><li>在 $q_1$ 读入 1 时，就“死掉”了；读入 0，继续到  $q_2$ </li><li>状态  $q_3$ 没有向外的跃迁，当在  $q_3$ 读入任何字符时，也会“死掉”</li></ul><h3 id="NFA-由五个元组组成："><a href="#NFA-由五个元组组成：" class="headerlink" title="NFA 由五个元组组成："></a>NFA 由五个元组组成：</h3><ul><li>$Q$ 是有限的状态集合</li><li>$\Sigma$ 是字母表</li><li>$ \delta : Q \times \Sigma \to Q$的子集，是转移函数</li><li>$q_0 \in Q$ 是初始状态</li><li>$F \subseteq Q$ 是接受状态的集合（最终状态，在图表中用双圈表示）</li></ul><p>只在 $ \delta $ 上和DFA有区别，$ \delta$ 是一个状态集合</p><h3 id="下面是一个-NFA-的图例："><a href="#下面是一个-NFA-的图例：" class="headerlink" title="下面是一个 NFA 的图例："></a>下面是一个 NFA 的图例：</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221003164555774.png" alt="image-20221003164555774"></p><h3 id="NFA-的语言："><a href="#NFA-的语言：" class="headerlink" title="NFA 的语言："></a>NFA 的语言：</h3><p>NFA 的语言是所有字符串的集合，其中存在某种路径，从初始状态开始，当字符串从左向右读取时，该路径将导致接受状态。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221003164700117.png" alt="image-20221003164700117"></p><p>NFA 可以做到一切 DFA 可以做到的事，但它不能做更多。</p><p>语言 L 如果可以被一些 DFA 接受，那么它一定可以被一些 NFA 接受。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Formal Languages</tag>
      
      <tag>Alphabet</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形式语言与自动机05 Regular Language</title>
    <link href="/2022/09/15/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA05-RegularLanguage/"/>
    <url>/2022/09/15/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA05-RegularLanguage/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Formal Languages</tag>
      
      <tag>Alphabet</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形式语言与自动机03-DFA</title>
    <link href="/2022/09/14/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA03-DFA/"/>
    <url>/2022/09/14/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA03-DFA/</url>
    
    <content type="html"><![CDATA[<h1 id="有限自动机-Finite-Automata"><a href="#有限自动机-Finite-Automata" class="headerlink" title="有限自动机 Finite Automata"></a>有限自动机 Finite Automata</h1><h2 id="一个有限自动机的例子"><a href="#一个有限自动机的例子" class="headerlink" title="一个有限自动机的例子"></a>一个有限自动机的例子</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220915095950200.png" alt="image-20220915095950200"></p><p>这是第一节课中给出的单开关灯泡电路的案例，这个例子中，有“开”和“关”两个状态，自动机的初始状态是“关”，并且尝试到达“好状态”——“开”。</p><p>那么要经历什么样的 f 操作序列才能到达好状态呢？</p><p>答案是：${ f, fff, fffff, …} &#x3D; {f ^n:n \ is \ odd }$</p><p>这是一个在字母表${f}$上的特定有限自动机的例子。</p><h2 id="确定有限自动机-Deterministic-finite-automata"><a href="#确定有限自动机-Deterministic-finite-automata" class="headerlink" title="确定有限自动机 Deterministic finite automata"></a>确定有限自动机 Deterministic finite automata</h2><h3 id="DFA-由五个元组组成："><a href="#DFA-由五个元组组成：" class="headerlink" title="DFA 由五个元组组成："></a>DFA 由五个元组组成：</h3><ul><li>$Q$ 是有限的状态集合</li><li>$\Sigma$ 是字母表</li><li>$ \delta : Q \times \Sigma \to Q$，一个转移函数</li><li>$q_0 \in Q$ 是初始状态</li><li>$F \subseteq Q$ 是接受状态的集合（最终状态，在图表中用双圈表示）</li></ul><h3 id="下面是一个-DFA-的图例："><a href="#下面是一个-DFA-的图例：" class="headerlink" title="下面是一个 DFA 的图例："></a>下面是一个 DFA 的图例：</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220918191913128.png" alt="image-20220918191913128"></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220918192934803.png" alt="image-20220918192934803"></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220918192833529.png" alt="image-20220918192833529"></p><h3 id="DFA-的语言："><a href="#DFA-的语言：" class="headerlink" title="DFA 的语言："></a>DFA 的语言：</h3><p>一个 DFA 的语言是在其字母表 Σ 上的字符串的集合，且若按照字符串顺序从左到右执行转化操作，可以从初始状态开始到达某个结束状态。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220918194221004.png" alt="image-20220918194221004"></p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Formal Languages</tag>
      
      <tag>Alphabet</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形式语言与自动机02-字母表和字符串</title>
    <link href="/2022/09/13/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA02-%E5%AD%97%E6%AF%8D%E8%A1%A8%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/09/13/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA02-%E5%AD%97%E6%AF%8D%E8%A1%A8%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="字母表和字符串"><a href="#字母表和字符串" class="headerlink" title="字母表和字符串"></a>字母表和字符串</h1><p>将词语、数字、词组等表示成字符串是一种常用方式，要定义字符串，就需要字母表；</p><p><strong>字母表是一个有限且非空的符号集合</strong>，例：</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912173147921.png" alt="image-20220912173147921" style="zoom:67%;" /><p><strong>字母表 Σ 上的字符串是一个 Σ 中符号的有限序列</strong>，空字符串表示为ε，例：</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912173540107.png" alt="image-20220912173540107" style="zoom:67%;" /><p><strong>语言是字母表上的字符串的集合</strong>，语言可以用于表示有 “YES&#x2F;NO” 答案的问题；</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912184330339.png" alt="image-20220912184330339" style="zoom:67%;" /><p>字母表总是有限的，而语言总是无限的（有限语言的研究价值太低）；</p><p>基于以上思想，我们将计算问题转化为集合归属问题来解决，例如：</p><p>一个计算问题为：数字 x 是素数吗？</p><p>可以转化为： $ x \in PRIMES &#x3D; {2,3,5,7,11,13,17,…} ?$</p><p>这里的 PRIMES 是一种语言， 是由字母表 $ \Sigma_2$ 中的字符串中的素数形成的语言；</p><h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><p>Concatenation 串联，无符号，直接连写即可<br>$$<br>w &#x3D; a_1a_2…a_n &amp;abba\<br>v &#x3D; b_1b_2…b_m &amp;bbbaaa\<br>wv&#x3D;a_1a_2…a_nb_1b_2…b_m &amp;abbabbbaaa<br>$$<br>Reverse 翻转，右上角 R，翻转字符串<br>$$<br>w &#x3D; a_1a_2…a_n &amp;abbab\<br>w^R&#x3D;a_n…a_2a_1 &amp;babba<br>$$<br>Length 取长度，绝对值符号，获取字符串长度<br>$$<br>w &#x3D; a_1a_2…a_n &amp;abba\<br>|w|&#x3D;n &amp;4<br>$$<br>对于空集 ε<br>$$<br>|\epsilon| &#x3D; 0\<br>\epsilon w &#x3D; w\epsilon &#x3D; w \<br>\epsilon abbac &#x3D; abb \epsilon ac &#x3D; abbac\epsilon &#x3D; abbac<br>$$<br>Substring 子字符串，一个连续字符的子序列</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912190914117.png" alt="image-20220912190914117" style="zoom:50%;" /><p>Prefix 前缀，Suffix 后缀，一个字符串可以分解为前缀和后缀两部分</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912191039457.png" alt="image-20220912191039457" style="zoom:50%;" /><p>Exponent 指数操作，即重复 n 次</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912191212589.png" alt="image-20220912191212589" style="zoom:50%;" /><p>* 操作，得到所有可能的字符串，总是无限的</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912191411160.png" alt="image-20220912191411160" style="zoom:50%;" /><p>+ 操作，得到除空集外的所有可能字符串，总是无限的</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912191633494.png" alt="image-20220912191633494" style="zoom: 50%;" /><p>现在我们可以得到语言的集合定义，即 <strong>任何一个在字母表 Σ 上的语言，都是 Σ* 的子集</strong>；</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912191920122.png" alt="image-20220912191920122" style="zoom:67%;" /><p>注意，空集也是一种语言，只有空字符串的集合也是语言；且这二者大小不同；</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912192349835.png" alt="image-20220912192349835" style="zoom:67%;" /><p>由于有限语言的研究价值较低，我们考虑无限的语言，如：</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912192217951.png" alt="image-20220912192217951" style="zoom:67%;" /><p>这里的语言 L 表示 a 的 n 次幂与 b 的 n 次幂的串联</p><h1 id="语言操作"><a href="#语言操作" class="headerlink" title="语言操作"></a>语言操作</h1><p>由于语言是一种集合，我们可以使用所有集合操作：</p><p>交、并、差：</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912192525934.png" alt="image-20220912192525934" style="zoom:67%;" /><p>补：</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912192604519.png" alt="image-20220912192604519" style="zoom:67%;" /><p>Reverse 翻转：</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912192730122.png" alt="image-20220912192730122" style="zoom: 67%;" /><p>串联：</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912192828517.png" alt="image-20220912192828517" style="zoom:67%;" /><p>注意，如果 L1 或 L2 为空集，连接的结果也为空集</p><p>幂次：</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912192859248.png" alt="image-20220912192859248" style="zoom:67%;" /><p>Star-Closure （ Kleene *)</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912193007657.png" alt="image-20220912193007657" style="zoom:67%;" /><p>Positive closure (+)</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912193101645.png" alt="image-20220912193101645" style="zoom:67%;" /><p>注意这里不能写为 L+ &#x3D; L* - ε，如果 L 中本身就有 ε，则会出错</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Formal Languages</tag>
      
      <tag>Alphabet</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形式语言与自动机01-自动机理论</title>
    <link href="/2022/09/12/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA01-%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    <url>/2022/09/12/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA01-%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是自动机理论？"><a href="#什么是自动机理论？" class="headerlink" title="什么是自动机理论？"></a>什么是自动机理论？</h1><ul><li>自动机理论是抽象计算设备（真实计算机的简化抽象模型）的研究</li><li>抽象模型可以帮助我们理解计算机，了解我们能用计算机做什么、做不了什么</li></ul><h2 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912164641093.png" alt="image-20220912164641093"></p><p>左图可以视为一个简单计算机系统，以开关信号作为<strong>输入</strong>，以灯泡作为<strong>输出</strong>，唯一的<strong>操作</strong>是“拨动开关，那么整个系统只存在两个<strong>状态</strong>：灯开和灯关；</p><p>该系统可以抽象为右侧的模型，并将初始状态设为灯关的情况，抽象为这样的模型后，我们可以直观的看到，当操作 f 执行奇数次的时候，灯是开启状态，执行偶数次则是关闭状态；</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912165223158.png" alt="image-20220912165223158"></p><p>当存在两个开关时，情况变得复杂了，抽象为右侧模型后，我们可以发现：只有两个开关都拨动奇数次时，灯才会是开的</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220912165808224.png" alt="image-20220912165808224"></p><p>如果要设计一个电路系统， 使得当且仅当所有开关拨动相同次数时，灯会开启，如何设计系统？</p><p>这样的复杂问题就需要更加强大的模型抽象能力去解决了，也就是自动机理论要解决的问题：我们能不能设计出这样的系统？如何设计这样的系统？</p><p>这些抽象模型可以用来描述许多小型计算机系统，比如微波炉或闹钟的控制组件；</p><p>这些模型同样也应用于词法分析器中，用于辨别编程语言的表达式是否正确，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// is a legal name of a variable in c</span><br><span class="hljs-type">int</span> ab1;<br><br><span class="hljs-comment">// is not</span><br><span class="hljs-type">int</span> <span class="hljs-number">5u</span>=;<br></code></pre></td></tr></table></figure><h2 id="不同种类的自动机"><a href="#不同种类的自动机" class="headerlink" title="不同种类的自动机"></a>不同种类的自动机</h2><p>上述的只是一种计算机设备，还有很多其他的种类：</p><table><thead><tr><th>自动机</th><th>内存</th><th>使用范围</th></tr></thead><tbody><tr><td>finite automata 有限自动机</td><td>设备内存有限；</td><td>用于建模小型计算机；</td></tr><tr><td>push-down automata 下推自动机</td><td>设备内存无限，以受限形式访问；</td><td>用于建模解析器等；</td></tr><tr><td>Turing Machines 图灵机</td><td>设备内存无限；</td><td>用于建模任何计算机；</td></tr><tr><td>time-bounded Turing Machines 有界图灵机</td><td>设备内存无线，但限制运行时间；</td><td>用于建模任何以“合理”时间运行的计算机程序</td></tr></tbody></table><p>本课程学习前两者：</p><p><strong>有限自动机：</strong>我们将学习有限内存的设备可以做什么，不可以做什么；介绍“模拟”：一个设备模仿另一个设备的能力；介绍“不确定性”：设备做出任意选择的能力；</p><p><strong>下推自动机：</strong>与语法有关的设备，描述了编程语言（以及自然语言）的结构；</p><p><strong>图灵机：</strong>是计算机的通用模型，计算出我们希望能计算的任何事物，；</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们要形式化的问题一定是有：”Yes&#x2F;No” 回答的问题， 比如：</p><ul><li>给定一个词语，是否含有给定的另一个词缀；</li><li>给定一个数 n ，能否被 7 整除？</li><li>给定一个含有括号的表达式，每个左括号都有与之匹配的右括号吗？</li></ul><p>这种问题中只有确定答案，不会出现：“寻找xxx”，“有多少xxx”的问题，这些问题我们暂不考虑</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Formal Languages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读03 知识图谱构建技术综述</title>
    <link href="/2022/08/31/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB03-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/"/>
    <url>/2022/08/31/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB03-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220829130310059.png" alt="image-20220829130310059"></p><p>​        </p><p>​        本周阅读的是《知识图谱构建技术综述》这篇论文，于 2016 年发表于《计算机研究与发展》，是课题组知识图谱研究方向的必读论文之一。本篇综述从技术框架和图谱定义出发，介绍了知识图谱的各类构建技术及其发展历程。以下是重点概念的笔记：</p><h2 id="1-知识图谱定义与架构"><a href="#1-知识图谱定义与架构" class="headerlink" title="1.知识图谱定义与架构"></a>1.知识图谱定义与架构</h2><p><strong>定义：</strong>结构化语义知识库，以<strong>符号形式</strong>描述物理世界中的<strong>概念</strong>及其<strong>相互关系</strong>。</p><p><strong>基本组成单位：</strong>“实体-关系-实体”三元组，“实体-属性”值对。</p><p><strong>研究价值：</strong>能够<strong>在 Web 网页之上</strong>建立概念间的链接关系，从而<strong>以最小代价</strong>将互联网累计的知识组织起来，成为<strong>真正可用的知识</strong>。</p><p><strong>应用价值：</strong>改变现有的“字符串模糊匹配”信息检索方式，通过推理<strong>实现真正的概念检索</strong>，并以图形化方式向用户<strong>展示经过分类整理的结构化知识</strong>。</p><p><strong>逻辑架构：</strong>包括将知识以事实为单位存储在图数据库的<strong>数据层</strong>，该层以“实体-关系-实体”三元组为事实的基本表达方式，大量数据构成实体关系网络，形成“图谱”；还包括存储经提炼之后的知识的<strong>模式层</strong>，该层为知识图谱的核心，往往采用本体库来管理该层。</p><p><strong>技术架构：</strong>知识图谱的构建是不断更新迭代的过程。每轮迭代包括三个阶段：<strong>信息抽取</strong>、<strong>知识融合</strong>、<strong>知识加工</strong>。即可以借助百科网站等结构化数据源以<strong>自顶向下</strong>的方式构建，也可以从公开数据中提取资源模式，选择置信度高的新模式，以<strong>自底向上</strong>的方式构建。</p><h2 id="2-知识图谱构建技术"><a href="#2-知识图谱构建技术" class="headerlink" title="2.知识图谱构建技术"></a>2.知识图谱构建技术</h2><h3 id="2-1-信息抽取"><a href="#2-1-信息抽取" class="headerlink" title="2.1.信息抽取"></a>2.1.信息抽取</h3><p>关键问题是<strong>如何从异构数据源中自动抽取信息得到候选知识单元</strong>。具体涉及到的关键技术包括：实体抽取、关系抽取 、属性抽取。</p><h4 id="2-1-1-实体抽取："><a href="#2-1-1-实体抽取：" class="headerlink" title="2.1.1,实体抽取："></a>2.1.1,实体抽取：</h4><p>也叫命名实体识别（named entity recognition，NER），从文本数据集中自动识别出命名实体，由于实体抽取的质量对后续的知识获取效率及质量影响极大，因此是信息抽取中<strong>最为基础和关键的部分</strong>。</p><p>早起使用<strong>基于规则的方法</strong>，但有明显局限性，且耗费巨大人力；</p><p>随后开始使用<strong>统计机器学习的方法</strong>辅助解决命名实体抽取问题；最近也开始采用<strong>有监督学习与规则结合</strong>的方法；</p><p>现今，学术界开始关注开放域的信息抽取问题，不在限定于特定知识领域，而面向开放的互联网。<strong>建立科学完整的命名实体分类体系</strong>也成为了了重要问题。</p><h4 id="2-1-2-关系抽取："><a href="#2-1-2-关系抽取：" class="headerlink" title="2.1.2.关系抽取："></a>2.1.2.关系抽取：</h4><p>经过实体抽取后只能得到离散的命名实体，还需要通过关系抽取提取实体之间的关联关系，才能形成网状知识结构。</p><p>早起采用人工构造语法语义规则，模式匹配的方式，有较大的局限性，对规则制定者有较高专业要求，工作量较大；</p><p>之后开始使用统计机器学习方法，且近年来逐渐转向半监督和无监督的学习方式；</p><p>此外，还有无需预先定义实体关系类型的面向开放域的关系抽取技术，这方面的研究重点是<strong>如何提升关系抽取的准确率和召回率</strong>，以及<strong>对隐含语义关系而非词汇关系的抽取</strong></p><h4 id="2-1-3-属性抽取："><a href="#2-1-3-属性抽取：" class="headerlink" title="2.1.3.属性抽取："></a>2.1.3.属性抽取：</h4><p>属性抽取的目标是<strong>从不同信息源中采集特定实体的属性信息</strong>，也可以将属性抽取问题转化为名字性的关系抽取问题</p><p>当前主要以百科类网站提供的半结构化数据为实体属性抽取研究的数据来源；</p><p><strong>如何从海量的非结构化数据中抽取实体属性</strong>是值得关注的理论研究问题：一种思路是基于百科类半结构化数据训练出模型，再应用于非结构化数据；另一种思路是基于数据挖掘直接获取实体与属性之间的关系模式。</p><h3 id="2-2-知识融合"><a href="#2-2-知识融合" class="headerlink" title="2.2.知识融合"></a>2.2.知识融合</h3><p>主要包括知识链接和知识合并，经过知识融合可以消除歧义，剔除冗余和错误概念，从而提升知识质量。</p><h4 id="2-2-1-实体链接："><a href="#2-2-1-实体链接：" class="headerlink" title="2.2.1.实体链接："></a>2.2.1.实体链接：</h4><p>实体链接（entity linking）对于从文本中抽取得到的实体对象，将其链接到知识库中对应的正确实体对象的操作。</p><p>基本思路是：对于给定实体，从知识库中筛选出一组候选对象，再计算相似度，从而链接到正确实体对象。</p><p>基本流程是：从文本中抽取实体，进行实体消歧，和共指消解，连接到对应实体</p><h5 id="2-2-1-1-实体消歧："><a href="#2-2-1-1-实体消歧：" class="headerlink" title="2.2.1.1.实体消歧："></a>2.2.1.1.实体消歧：</h5><p>实体消歧（entity disambiguation）专门用于解决同名实体产生歧义的技术，用于解决<strong>某个实体对应于多个实体对象的问题</strong>（例：李娜可以指向歌手李娜也可以指向网球运动员李娜）。</p><p>聚类法消歧可以将所有指向同一实体对象的指称项聚集到该对象的中心类别之下，常用的方法有：空间向量模型（词袋模型）、语义模型、社会网络模型、百科知识模型等</p><h5 id="2-2-1-2-共指消解："><a href="#2-2-1-2-共指消解：" class="headerlink" title="2.2.1.2.共指消解："></a>2.2.1.2.共指消解：</h5><p>共指消解（entity resolution）用于解决<strong>多个指称项对应于同一实体对象的问题</strong>（例：在同一篇新闻中，”Barack Obama” 和 “president Obama” 以及 “the president” 等指称项可能指向的是同一个实体对象）</p><h4 id="2-2-2-知识合并："><a href="#2-2-2-知识合并：" class="headerlink" title="2.2.2.知识合并："></a>2.2.2.知识合并：</h4><p><strong>合并外部数据库：</strong>数据层融合需要解决实例与关系之间的冲突问题以及冗余问题；模式层融合可将新得到的本体融入已有本体库中。</p><p>基本流程为：获取知识、概念匹配、实体匹配、知识评估。</p><p><strong>合并关系型数据库：</strong>将关系型数据库的数据转换为 RDF 三元组数据，该类技术也可应用于其他半结构化数据。</p><h3 id="2-3-知识加工"><a href="#2-3-知识加工" class="headerlink" title="2.3.知识加工"></a>2.3.知识加工</h3><p>主要包括：本体构建、知识推理和质量评估。</p><h4 id="2-3-1-本体构建："><a href="#2-3-1-本体构建：" class="headerlink" title="2.3.1.本体构建："></a>2.3.1.本体构建：</h4><p>本体是对概念进行建模的规范，是描述客观世界的抽象模型。</p><p>本体反映的知识是一种明确定义的公式，是共享的；本体是树状结构的，相邻层次之间有严格的 “Is A” 关系</p><h4 id="2-3-2-知识推理："><a href="#2-3-2-知识推理：" class="headerlink" title="2.3.2.知识推理："></a>2.3.2.知识推理：</h4><p>知识推理是指从已有实体关系数据出发，经计算机推理得到实体间的新管理，从而拓展和丰富知识网络的过程。</p><p>推理方法可以分为：基于逻辑的推理（一阶谓词逻辑、描述逻辑、基于规则的逻辑）和基于图的推理（神经网络模型、Path Ranking 算法）。</p><h4 id="2-3-3-质量评估："><a href="#2-3-3-质量评估：" class="headerlink" title="2.3.3.质量评估："></a>2.3.3.质量评估：</h4><p>质量评估是知识库扣减技术的重要组成部分，引入质量评估可以对知识的可信度进行量化，并通过舍弃置信度较低的知识来保障并提升知识库质量。</p><h3 id="2-4-知识更新"><a href="#2-4-知识更新" class="headerlink" title="2.4.知识更新"></a>2.4.知识更新</h3><p>知识图谱的构建是不断更新迭代的过程，有两种方式：</p><p>全面更新：以更新后的全部数据为输入，从零开始重新构建；特点是操作简单，资源消耗大，维护开销大；</p><p>增量更新，以当前新增数据作为输入，向现有图谱中新增；特点是操作复杂，资源消耗小，干预开销大。</p><h2 id="3-跨语言知识图谱构建"><a href="#3-跨语言知识图谱构建" class="headerlink" title="3.跨语言知识图谱构建"></a>3.跨语言知识图谱构建</h2><p><strong>意义：</strong></p><ol><li>各语种知识分布不均匀，跨语言构建知识图谱可以弥补单语种知识库的不足；</li><li>可以充分利用多语种在知识表达方式上的互补性，从而增加知识覆盖率和共享度；</li><li>通过不同语言对同一知识的表述实现错误信息过滤。</li></ol><h2 id="4-知识图谱应用"><a href="#4-知识图谱应用" class="headerlink" title="4.知识图谱应用"></a>4.知识图谱应用</h2><ol><li><p>智能语义搜索应用：对搜索关键字进行解析和推理，映射到图谱中的概念上，再返回图形化的知识结构（如百度、谷歌搜索得到的知识卡片）；</p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220830223809812.png" alt="image-20220830223809812" style="zoom:50%;" /></li><li><p>深度问答应用：对问题进行语义分析和语法分析，转化为结构化的查询语句，再在图谱中查询答案（对与知识库中没有答案的情况，采用知识推理技术给出）；</p></li></ol><h2 id="5-问题与挑战"><a href="#5-问题与挑战" class="headerlink" title="5.问题与挑战"></a>5.问题与挑战</h2><ol><li>面向开放域的信息抽取方法仍处于起步阶段；</li><li>知识融合环节中，如何实现准确的实体链接；</li><li>知识加工过程中的推理技术亟待突破；</li><li>知识更新环节严重依赖人工干预；</li><li>如何解决知识的表达、存储与查询问题。</li></ol>]]></content>
    
    
    <categories>
      
      <category>PaperReading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KnowledgeGraph</tag>
      
      <tag>Summarize</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习04 Transformer</title>
    <link href="/2022/08/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A004-Transformer/"/>
    <url>/2022/08/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A004-Transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><h2 id="Transformer-是什么？"><a href="#Transformer-是什么？" class="headerlink" title="Transformer 是什么？"></a>Transformer 是什么？</h2><p>本质上是一种 Sequence to sequence (Seq2seq) 的转换</p><p>输入是序列，输出也是序列（输出长度不确定）</p><p>适合用于语音识别（现在多使用 RNN-Transducer）、文本翻译、QA、NLP（转化为QA）等（输出序列长度不确定，没有明确关系）</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414014551597.png" alt="image-20220414014551597"></p><p>也可用于 Multi-label Classification 多标签分类</p><p>输入符合输出结果中的多种标签，是一对多的分类问题，比如输入是一篇文章，输出既有语言，又有体裁，又有正负面评价等等标签。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414020620729.png" alt="image-20220414020620729"></p><p>Multi-class Classification 多类别分类（传统分类问题，与前者区分）</p><p>输入属于输出结果中的某一个类，是一对一的分类问题，比如输入是一段语音，输出分类为中文或英文（看似与多标签分类问题相似，实际两者很难用同一类模型解决）</p><h2 id="Seq2seq-基本结构"><a href="#Seq2seq-基本结构" class="headerlink" title="Seq2seq 基本结构"></a>Seq2seq 基本结构</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414021014715.png" alt="image-20220414021014715"></p><p>基本结构：输入序列经过 **编码器 Encoder **部分处理，交由 **解码器 Decoder **处理为输出序列</p><h3 id="Encoder-编码器"><a href="#Encoder-编码器" class="headerlink" title="Encoder 编码器"></a>Encoder 编码器</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414021341139.png" alt="image-20220414021341139"></p><p>Encoder 的任务是将一个向量输入转化为另一个向量输出，可以使用 RNN、CNN 等各种模型。</p><h3 id="Decoder-解码器"><a href="#Decoder-解码器" class="headerlink" title="Decoder 解码器"></a>Decoder 解码器</h3><h4 id="Autoregressive-Decoder-自回归解码器"><a href="#Autoregressive-Decoder-自回归解码器" class="headerlink" title="Autoregressive Decoder 自回归解码器"></a>Autoregressive Decoder 自回归解码器</h4><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414023057892.png" alt="image-20220414023057892"></p><p>以语音识别为例，Decoder 将 Encoder 的输出作为输入，在得到开始信号（BEGIN）之后，计算得到第一个输出结果，并将这一结果连同 Encoder 输出作为新的输入，计算得到下一个输出结果，如此反复直到输出结束</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414023356616.png" alt="image-20220414023356616"></p><p>事实上，编解码器结构是比较相似的。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
      <tag>DeepLearning</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习06 GAN</title>
    <link href="/2022/08/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A006-GAN/"/>
    <url>/2022/08/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A006-GAN/</url>
    
    <content type="html"><![CDATA[<h1 id="生成网络-Generator"><a href="#生成网络-Generator" class="headerlink" title="生成网络 Generator"></a>生成网络 Generator</h1><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221128182052578.png" alt="常规网络"></p><p><strong>常规的回归任务</strong>可以看做如上结构，x 作为输入进入网络进行运算，得到对应输出 y，<strong>对于给定的 x，一定会得到相同的y</strong></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221128181938026.png" alt="生成网络"></p><p><strong>生成器网络</strong>则在常规网络的基础上<strong>增加了新的输入 z</strong>，且输入 z 往往是通过简单分布（如高斯分布）采样得到一个随机值，将 x 和 z 一起输入网络，由于 z 的取值是随机的，<strong>对于同一个 x 也会得到不同的 y</strong>，这就使得网络的输出从固定值变成了一个 y 的分布。</p><h2 id="为什么采用这种做法？"><a href="#为什么采用这种做法？" class="headerlink" title="为什么采用这种做法？"></a>为什么采用这种做法？</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221128184302188.png" alt="有“创造性”的任务"></p><p>在绘画、作文等需要“创造性”的任务中，我们不希望模型的输出是一成不变的，即对于同样的输入，能够得到不同的输出，且这种输出是符合某种概率分布的（用概率来约束）。</p><h1 id="GAN-（Generative-Adversarial-Network-对抗生成网络）"><a href="#GAN-（Generative-Adversarial-Network-对抗生成网络）" class="headerlink" title="GAN （Generative Adversarial Network 对抗生成网络）"></a>GAN （Generative Adversarial Network 对抗生成网络）</h1><p>GAN 的基本思想是“对抗”，即构建两个神经网络：<strong>generator 生成器</strong> 和 <strong>discriminator 判别器</strong></p><p><img src="C:\Users\19658\AppData\Roaming\Typora\typora-user-images\image-20221128190253148.png" alt="对抗生成的过程"></p><p>生成器用于生成内容，其结果将交由判别器进行真实性判定，判别器会对生成器得到的结果进行打分（scale），两个神经网络一同训练，判别器为了区分内容的真假在不断进化，生成器为了“骗过”判别器也要进化，从而生成更逼真的内容。</p><p>两个神经网络在对抗过程中不断进化，最终就能产生以假乱真的内容。</p><h2 id="训练过程："><a href="#训练过程：" class="headerlink" title="训练过程："></a>训练过程：</h2><h3 id="第一步：固定生成器，更新判别器"><a href="#第一步：固定生成器，更新判别器" class="headerlink" title="第一步：固定生成器，更新判别器"></a>第一步：固定生成器，更新判别器</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221128191154632.png" alt="判别器更新"></p><p>首先初始化生成器参数，然后将其固定不变，就可以通过生成器得到输出结果（由于未经训练，其结果可能与真实情况相差甚远，甚至全是噪声）</p><p>之后将真实数据和这些结果交给判别器，判别器可以将其视为一个分类任务或者回归任务，对生成器的结果进行打分，分数越高越真实。训练目的是能让判别器的判别结果尽可能向真实情况靠拢，即生成器结果判假，真实数据判真。</p><p>通过这一部分训练，增强判别器的判别能力。</p><h3 id="第二步：固定判别器，更新生成器"><a href="#第二步：固定判别器，更新生成器" class="headerlink" title="第二步：固定判别器，更新生成器"></a>第二步：固定判别器，更新生成器</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221128191723743.png" alt="生成器更新"></p><p>这一阶段将判别器参数固定，将生成器得到结果交给判别器进行打分，以提高判别器分数为目的对生成器进行训练。</p><p>通过这一部分训练，增强生成器的生成能力。</p><h3 id="第三步：重复前两个步骤，反复执行"><a href="#第三步：重复前两个步骤，反复执行" class="headerlink" title="第三步：重复前两个步骤，反复执行"></a>第三步：重复前两个步骤，反复执行</h3><p>通过反复训练两个网络，通过对抗完成生成过程。</p><h2 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h2><h3 id="生成人脸："><a href="#生成人脸：" class="headerlink" title="生成人脸："></a>生成人脸：</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221128193219369.png" alt="Progressive GAN"></p><p>除了动漫和文字，GAN 也可以用于生成人脸，而且这些人脸是数据集中没有出现过的，新的人脸。</p><h3 id="生成中间过程："><a href="#生成中间过程：" class="headerlink" title="生成中间过程："></a>生成中间过程：</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221128192635758.png" alt="对输入向量进行插值得到中间过程"></p><p>对于最左侧和最右侧两个输入，我们可以通过对这两个输入向量做内插，来得到这两个输入之间的值对应的生成结果，可以得到更多的输入，整个序列构成了一个连续的变化。</p><h1 id="GAN-的理论分析"><a href="#GAN-的理论分析" class="headerlink" title="GAN 的理论分析"></a>GAN 的理论分析</h1>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
      <tag>DeepLearning</tag>
      
      <tag>GAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习07 Auto-Encoder</title>
    <link href="/2022/08/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A007-Auto-Encoder/"/>
    <url>/2022/08/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A007-Auto-Encoder/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
      <tag>DeepLearning</tag>
      
      <tag>Auto-Encoder</tag>
      
      <tag>Self-supervised Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习05 自监督学习</title>
    <link href="/2022/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A005-%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A005-%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Self-supervised-Learning-自监督学习"><a href="#Self-supervised-Learning-自监督学习" class="headerlink" title="Self-supervised Learning 自监督学习"></a>Self-supervised Learning 自监督学习</h1><h2 id="Supervised-监督"><a href="#Supervised-监督" class="headerlink" title="Supervised 监督"></a>Supervised 监督</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414013529142.png" alt="image-20220414013529142"></p><p>训练数据集是需要标注的，即已知结果的学习过程，通过确定的结果让机器知道学习方向</p><h2 id="Self-Supervised-自监督"><a href="#Self-Supervised-自监督" class="headerlink" title="Self-Supervised 自监督"></a>Self-Supervised 自监督</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414013744717.png" alt="image-20220414013744717"></p><p>将数据集 x 分为两部分，一部分 x’ 作为输入，另一部分 x” 用于校验输出效果，我们希望模型的输出结果 y 与 x” 越接近越好</p><h1 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h1><p>接下来以 BERT 为例，来解释自监督学习</p><p>BERT 与 Transformer Encoder 相同</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221129153513808.png" alt="image-20221129153513808"></p><p>在输入时，我们随机的将输入向量的某个部分遮盖（MASK），可以用特殊标记或或者随机值来进行 MASK</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221129154226074.png" alt="image-20221129154226074"></p><p>之后，通过这个 Transformer Encoder，我们可以得到一个向量，再将这个向量通过一个 Linear 的 Model 和 softmax层，得到 MASK 部分的预测，由于原输入是已知的，我们不需要再找新的数据集来训练，只需要和原数据作比较就能知道预测结果的好坏</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221129154446985.png" alt="image-20221129154446985"></p><p>到此为止，BERT 貌似在解决一个“填空”问题，但事实上，BERT 真正的强大之处在于，他可以应用到 <strong>下游任务（Downstream Tasks）</strong> 上 </p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221129163920602.png" alt="image-20221129163920602"></p><p>下游任务是我们真正关心的任务，这个任务可能和“填空”没有什么关系，但我们可以用 BERT 这个 <strong>预训练 Pre-train</strong> 的模型，来帮助解决这些下游任务。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
      <tag>DeepLearning</tag>
      
      <tag>Self-Supervised-Learning</tag>
      
      <tag>BERT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习03 CNN</title>
    <link href="/2022/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A003-CNN/"/>
    <url>/2022/08/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A003-CNN/</url>
    
    <content type="html"><![CDATA[<h1 id="Convolutional-Neural-Network（CNN）"><a href="#Convolutional-Neural-Network（CNN）" class="headerlink" title="Convolutional Neural Network（CNN）"></a>Convolutional Neural Network（CNN）</h1><p>CNN 通常用于图片识别上</p><h2 id="图片对计算机来说是什么？"><a href="#图片对计算机来说是什么？" class="headerlink" title="图片对计算机来说是什么？"></a>图片对计算机来说是什么？</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220430192356542.png" alt="image-20220430192356542"></p><p>对于计算机而言，图片是一个3维度的张量（tensor），分别是：长、宽、通道数值。 </p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
      <tag>DeepLearning</tag>
      
      <tag>CNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习02 常见问题</title>
    <link href="/2022/07/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A002-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A002-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>当学习结果不够好的时候，通常是按照如下步骤进行 的：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414194117158.png" alt="image-20220414194117158"></p><p>首先检查训练数据上的 LOSS，如果 LOSS 已经很大，那么基本上是两种情况：一种是模型偏差，一种是最优解没有找到</p><h2 id="模型偏差-Model-Bias"><a href="#模型偏差-Model-Bias" class="headerlink" title="模型偏差 Model Bias"></a>模型偏差 Model Bias</h2><p>模型过于简单，无论何种参数都无法获得较好的 LOSS，这是通常要改变模型设计，通过增加 Feature 、增加更多 Layer 等方法使模型更加复杂多变。</p><h2 id="最优解问题-Optimization-Issue"><a href="#最优解问题-Optimization-Issue" class="headerlink" title="最优解问题 Optimization Issue"></a>最优解问题 Optimization Issue</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414194526695.png" alt="image-20220414194526695"></p><p>仅仅获得了局部最优解，没有找到真正的最优解，可以先尝试使用简单模型（易于求解最优解的方法），或使用更深层次（如果更深层次表现反而不好，多数情况下是最优解问题）</p><p>在训练数据上已经获得了较好的 LOSS 之后，再查看测试数据上的 LOSS，如果测试数据上的 LOSS 已经够小，则问题已经基本解决，如果测试数据上的 LOSS 仍然较大，则可能是出现了 <strong>Overfitting 过拟合</strong> 问题</p><h2 id="过拟合-Overfitting"><a href="#过拟合-Overfitting" class="headerlink" title="过拟合 Overfitting"></a>过拟合 Overfitting</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414200050052.png" alt="image-20220414200050052"></p><p>训练得到的函数在训练数据上表现得好，但在没有训练数据的部分上“自由发挥”了，导致 LOSS 较大</p><p>如何解决呢？</p><ol><li>增加训练数据或创造更多数据（从已有数据生成，如图像识别问题，可以左右翻转图片）</li><li>限制模型，降低模型弹性（降低参数数量、神经元数量、共享参数等）</li><li>减少 Feature</li><li>Early stopping</li><li>Regularization</li><li>Dropout</li></ol><p>也可以将训练数据分为训练集和确认集，用确认集来模拟测试的过程，分解方式可以选择如下的方式：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414204910006.png" alt="image-20220414204910006"></p><p>将数据等分为多份，之后将不同的部分轮流作为确认集进行测试。</p><h2 id="Mismatch-误配"><a href="#Mismatch-误配" class="headerlink" title="Mismatch 误配"></a>Mismatch 误配</h2><p>除了 Overfitting 问题外，实际情况上的模型表现不好，也有可能是出现了 Mismatch 问题，由于一些其他原因导致，而非模型本身的问题。</p><h2 id="Saddle-Point-鞍点"><a href="#Saddle-Point-鞍点" class="headerlink" title="Saddle Point 鞍点"></a>Saddle Point 鞍点</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220425121948271.png" alt="image-20220425121948271"></p><p>除了 Local Minima 局部最优的情况之外，还有另一种情况，loss也很难下降，这种情况下某一方向上是极小值，某一方向上又是极大值，使得其微分为0，也就是 Saddle Point 鞍点，与 Local Minima 统称为 Critical point 临界点。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
      <tag>DeepLearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习01 介绍</title>
    <link href="/2022/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A001-%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A001-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>台大李宏毅老师机器学习课程学习笔记，重新整理：</p><h2 id="Machine-Learning-≈-Looking-for-Function"><a href="#Machine-Learning-≈-Looking-for-Function" class="headerlink" title="Machine Learning ≈ Looking for Function"></a>Machine Learning ≈ Looking for Function</h2><p>简单来说，机器学习的实质是<strong>寻找一个难以用人力创造的函数</strong></p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314151118633.png" alt="image-20220314151118633"></p><p>很多复杂问题都能概括为寻求一个函数，给定输入，以期望得到某个正确的输出。</p><ul><li>语音识别：给定音频信号，输出对应语言的文字</li><li>图像识别：给定图片数据，输出对应事物的名称</li><li>围棋AI：给定棋盘数据，得到胜率最高达的下一步坐标</li></ul><p>但这些问题通常难以解决，特别是涉及高维和低维信息之间转换的问题，难以用传统方法寻求二者之间的联系。</p><p>随着计算机算力水平的提升，用机器每秒上百万次的强大运算能力来“暴力破解”输入输出之间的关系也不再是空谈，这就是机器学习。</p><h2 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h2><p>简单来说机器学习可以分为以下三类：</p><p><strong>Regression（回归）</strong>：让函数得到某个数值。如 PM2.5 预测</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314151404348.png" alt="image-20220314151404348"></p><p><strong>Classification（分类）</strong>：给出一些选项（类别），函数输出正确的选项。如垃圾邮件分类</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314151527247.png" alt="image-20220314151527247"></p><p> <strong>Structured Learning（结构）</strong>：构建出具有结构的输出。如生成图像，文档</p><h2 id="如何获得这个函数？"><a href="#如何获得这个函数？" class="headerlink" title="如何获得这个函数？"></a>如何获得这个函数？</h2><p>函数由表达式、输入和输出组成，第一步就是写出表达式：</p><h3 id="1-写出带有未知参数的函数"><a href="#1-写出带有未知参数的函数" class="headerlink" title="1.写出带有未知参数的函数"></a>1.写出带有未知参数的函数</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314164944251.png" alt="image-20220314164944251"></p><p>其中，y是函数结果，x1是输入。</p><p>通常而言，我们不表达式都不是上图这种简单的线性方程，具体函数形式基于不同的问题而定，上面的例子中，习惯将w称作权重，b称作偏差。</p><p>如何选择合适的表达式，构建出符合问题要求的模型，是当下机器学习领域的重点之一。</p><p>不难看出，上述表达式中存在很多未知的参数，这些参数就是要求解部分，得到参数后，对于任意给定的输入均能得到对应输出。</p><p>那么参数如何计算得到呢？</p><p>要计算参数，可以通过对已知结果逆运算得出，这些已知的“输入”被称为特征，“输出”被称为标记，共同构成了训练数据。</p><p>如果有海量的训练数据，就能通过这些数据反推出合适的参数，从而得到最终的表达式。为此需要有一个衡量参数好坏的函数，在每一次使用训练数据计算参数时，对参数进行评估，从而方便下一步对参数进行调整。</p><h3 id="2-基于训练数据计算-Loss"><a href="#2-基于训练数据计算-Loss" class="headerlink" title="2.基于训练数据计算 Loss"></a>2.基于训练数据计算 <strong>Loss</strong></h3><p>Loss 是计算结果偏差的函数，用于衡量当前得到的未知参数的好坏。</p><p>在第一次计算时，我们可以随机对参数进行赋值，将输入代入表达式，得到预测结果，之后与 <strong>Label（真实数据）</strong> 计算Loss（通常是MAE、MSE等差额计算）。从而反映出本次表达式所使用的的参数的优劣程度。</p><p>如果将各种可能的未知参数都尝试一遍，计算出相应的 Loss，绘制出 <strong>”Error Surface“</strong>，可以观测到最合适的未知参数。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314170218911.png" alt="image-20220314170218911"></p><p>但真实情况中，由于参数众多，形式复杂，很难用图像直观表达出来，只能得到不同情况下参数对应的 Loss 值。</p><p>在得到 Loss 后，我们就了解了目前的参数的优劣，之后就需要将参数进行调整，使计算结果更加贴近真实值，让 Loss 越来越小，也就是 Optimization（优化） 的过程。</p><h3 id="3-优化"><a href="#3-优化" class="headerlink" title="3.优化"></a>3.优化</h3><p>获得最佳的未知参数，可以使用 <em><strong>Gradient Descent（梯度下降）</strong></em> ，单个参数的该算法步骤如下：</p><p>首先，随机选取一个 w 作为初始值</p><p>其次，计算该 w 对应的 loss 值，并计算 L 在 w 上的微分（即斜率）</p><p>​        通过这一步，我们可以确定此时的 w 值是偏大还是偏小，如果斜率为正，说明 w 增加会增大 Loss，w 减少则会减少 Loss，斜率为负值则相反，</p><p>之后，我们需要设定一个 <strong>η（学习速率）</strong>，来划定我们每次对 w 的变化大小， 对 w 进行变化（用 η 乘上微分）后反复如上的计算，从而获得最佳的未知参数。这些由我们自己设定的参数被称为 <em><strong>Hyperparameters（超参数）</strong></em></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314171705030.png" alt="image-20220314171705030"></p><p>然而，我们很容易发现，这种方法在微分值为0时就会停止，得到的参数可能只是局部最佳值，而非全局最佳值。不过尽管 Gradient Descent 存在这一问题，但在实际生产实践中可以通过取多次随机点的方式轻松解决，这一方法的真正痛点另有别处。</p><p>相应的，多参数方法也很容易得到：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314172110989.png" alt="image-20220314172110989"></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314172226936.png" alt="image-20220314172226936"></p><h2 id="如何改进？"><a href="#如何改进？" class="headerlink" title="如何改进？"></a>如何改进？</h2><p>经过上述的三个基本步骤，我们很容易就能计算出“最佳”的未知参数，但事实上，这种预测往往存在较大偏差，在上述例子中，我们选用的是最简单的 <strong>Liner Model（线性模型）</strong>，即使用权重和偏差值来进行预估的简单模型，这种模型考虑的因素少，性能有限，只能表现线性的单调变化。</p><p>实际问题中，我们往往需要更加贴合实际问题的模型，这才是机器学习的难点所在。</p><h3 id="Sigmoid-Function（S形函数）"><a href="#Sigmoid-Function（S形函数）" class="headerlink" title="Sigmoid Function（S形函数）"></a>Sigmoid Function（S形函数）</h3><p>由于函数变化多种多样，我们可以将函数分为多段，每一段视为一个斜率近似固定的直线，这样我们就将一条曲线分解为了多段曲线之和，每一段曲线的其他部分均为常数，只有在与其斜率吻合的部分是有斜率的，即下图的 <strong>Hard Sigmoid（硬S函数）</strong></p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314182644869.png" alt="image-20220314182644869"></p><p>由于分段函数表达式不便于计算，我们使用 <strong>Sigmoid Function（S形函数）</strong>来近似的表达这些曲线。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314183750691.png" alt="image-20220314183750691"></p><p>其中，w 用于改变斜率，b 用于改变左右位置，c 改变高度</p><p>这样我们就能将曲线拆分为多个 Sigmoid Function 之和：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314183859065.png" alt="image-20220314183859065"></p><p>将这一程序化过程用线性代数表示即为如下方式：<img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314184826782.png" alt="image-20220314184826782"></p><p>将其中的未知参数拼接为向量 θ ：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314185208598.png" alt="image-20220314185208598"></p><p>此时，Loss 计算方法不变，仍然是给定一组 θ ，与真实值 label 进行对比即可：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314195756458.png" alt="image-20220314195756458"></p><p>参数优化方法也仍然相似：</p><p>​找出初始值（随机）；</p><p>​求参数向量的微分向量（ <em>gradient</em> ）；</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314195956073.png" alt="image-20220314195956073"></p><p>​更新 θ 向量：    </p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314200128627.png" alt="image-20220314200128627"></p><p> 重复计算和更新，直到计算结束（无法计算或重复一定次数）</p><h3 id="分组（Batch）优化"><a href="#分组（Batch）优化" class="headerlink" title="分组（Batch）优化"></a>分组（Batch）优化</h3><p>之前计算 Loss 时，我们将全部输入与真实值对比得到 Loss，另一种方法是，将整个数据集分为一个个 <strong>Batch</strong>，每个 Batch 大小相同，具体大小随意。</p><p>每次对一个组进行 Loss 计算，之后使用这个 Loss 计算 gradient，使用这个 gradient 更新参数向量 θ，再将这个新的 θ 放到 下一个组中计算 Loss，如此重复直到所有的组完成一次计算，这样就对<strong>所有数据完成了一次训练</strong>，即一次 <strong>Epoch</strong>。</p><p>在这一次 epoch 中，更新了相当于 batch 数量的 update 次数。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314202247672.png" alt="image-20220314202247672"></p><h3 id="Rectified-Linear-Unit（ReLU函数"><a href="#Rectified-Linear-Unit（ReLU函数" class="headerlink" title="Rectified Linear Unit（ReLU函数)"></a>Rectified Linear Unit（ReLU函数)</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314202456620.png" alt="image-20220314202456620"></p><p>除了 S 形函数外，也可以使用上图所示的 ReLU 函数 ，两个 ReLU 函数相加就能得到一个 S 形函数表示的折线：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314202848249.png" alt="image-20220314202848249"></p><p>在列出表达式时需要注意：<img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314202931594.png" alt="image-20220314202931594"></p><p>相较于线性模型，使用 ReLU 可以带来较为显著的提升，课程样例的结果如下：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314203137316.png" alt="image-20220314203137316"></p><p>可以看到当 ReLU 数量较少时效果一般，但当 ReLU 数量较多时，更加贴合的曲线就能带来更好的预测效果。</p><h3 id="“套娃”"><a href="#“套娃”" class="headerlink" title="“套娃”"></a>“套娃”</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314203526849.png" alt="image-20220314203526849"></p><p>我们也可以使用 ReLU 等模型进行反复“套娃处理”，多进行几层，增加更多的参数，进行更相似的拟合，得到更好的预测效果：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314203800478.png" alt="image-20220314203800478"></p><p>经过上述优化，我们得到的曲线如下图蓝色曲线所示，尽管已经非常贴近，但一些意外（如下图拟合失误的部分，正处于除夕，计算机无法预测到这一影响）</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314203951386.png" alt="image-20220314203951386"></p><h2 id="神经网络-amp-深度学习"><a href="#神经网络-amp-深度学习" class="headerlink" title="神经网络 &amp; 深度学习"></a>神经网络 &amp; 深度学习</h2><p>由于整个计算过程中有大量的 Sigmoid 或者 ReLU 这样的小单元，就好像一个个神经元一样，我们将每个 Sigmoid 或者 ReLU 称为 <strong>Neuron（神经元）</strong>，整个模型被称为 <strong>Neural Network（神经网络）</strong></p><p>像上文提到的<strong>“套娃”</strong>一样，有着多层嵌套结构的机器学习，就称为 <strong>Deep Learning 深度学习</strong></p><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>1.既然任何曲线都可用多段的 ReLU 或 Sigmoid 拼接，为什么不使用更多的神经元来模拟，而进行这种增加层数的操作呢？</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314210841598.png" alt="image-20220314210841598"></p><p>2.层数越多越好吗？然而现实中，经常出现 <strong>Overfitting（过拟合）</strong>问题，即训练资料上表现好，但在预测中表现不好，那我们该采用多少层的模型呢？又如何解决 Overfitting 问题呢？</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314211103505.png" alt="image-20220314211103505"></p><p>（事实上，大所数有更多层次的模型表现不好的问题根源在于最优解没有找到，由于梯度下降方法往往只能得到局部最优解，所以产生了更差的效果，并非过拟合的情况）</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
      <tag>DeepLearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读02 TransE</title>
    <link href="/2022/07/24/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB02-TransE/"/>
    <url>/2022/07/24/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB02-TransE/</url>
    
    <content type="html"><![CDATA[<p>前段时间忙家里各种杂事，只看了师兄给的一篇表示学习综述，大概了解了一下知识图谱和表示学习相关的技术，接下来计划将一些重要模型进一步学习，自己尝试实现一下，这里就以 TransE 作为开头，开个新坑。</p><h1 id="TransE-原理"><a href="#TransE-原理" class="headerlink" title="TransE 原理"></a>TransE 原理</h1><p>TransE 模型来源于 <a href="https://dl.acm.org/doi/10.5555/2999792.2999923">Translating embeddings for modeling multi-relational data</a> 这篇论文，从标题上不难看出，TransE 将表示学习的过程看做是<strong>“翻译”</strong>的过程。其基本思想是，将知识三元组中的 relation 看做从 head 到 tail 的翻译过程，如果将这些关系都用向量表示，则应满足</p><p>$$<br>head + relation \approx tail<br>$$<br>为了让 relation 的表示能够达到以上要求，TransE 定义了一个距离函数 $d(h + r, t)$来计算头实体和为尾实体之间的距离，原论文使用的是欧氏距离，也可以使用曼哈顿距离。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/v2-c271aad4fc8f9026b19dc31246c3b50c_1440w.jpg" alt="img"></p><p>如果成功构建了这样规则下的网络关系，那么就可以根据一个实体和关系来预测另一个实体，或者通过两个实体直接预测它们的关系。</p><h1 id="TransE-训练"><a href="#TransE-训练" class="headerlink" title="TransE 训练"></a>TransE 训练</h1><p>训练时首先随机生成初始实体向量和关系向量，用于表示知识图谱。整个训练的目的就是求解正确的向量数值，损失函数可以使用 $d(h + r, t)$ 来计算，分为两个方向，正确的三元组应当有更小的 $d$，错误的三元组的 $d$ 则是越大越好。这种方法就是 <strong>negative sampling</strong>，<strong>即相对于负例，正例的得分更高</strong>。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/20190504222759459.png" alt="在这里插入图片描述"></p><p>其中 $(h’,l,t’)$ 称为 <strong>corrupted triplet</strong>，是非同时随机替换头或尾实体得到的负例（也可以替换relation）。$\gamma$ 为 margin。事实上这就是在计算 Soft-margin Loss，可以认为，transE针对给定三元组进行二分类任务，其中负例是通过替换自行构造的，目标是使得最相近的正负例样本距离最大化。</p>]]></content>
    
    
    <categories>
      
      <category>PaperReading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RepresentationLearning</tag>
      
      <tag>TransE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重启Github博客</title>
    <link href="/2022/07/22/%E9%87%8D%E5%90%AFGithub%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/07/22/%E9%87%8D%E5%90%AFGithub%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>前段时间码云大面积封禁了图床仓库，前面大概几十篇博客的图链都挂了，要逐一去修改这几百张图的链接想想都头大…</p><p>之前用码云还是因为国内用 Github 不是很方便，经常打不开。但考虑到之前码云对 Git page 的整改，以及最近针对图床和仓库的各种操作，还是打算换回 Github 用。</p><p>回头看大学这几年的博客，就是自己大学四年的缩影：大一初识编程，博客里除了七零八碎的小知识就是期末复习；大二开始接触各类前后端框架，就开始满是环境配置和框架特性了；再到大三考研备考，博客不怎么写了，只有一篇马原的总结；最后大四了才开始了解机器学习，又是一片新天地。</p><p>初期博客写作质量不够高，大多是知识的简单复述，博客主题也有点过于花里胡哨。这次换了个纯粹简约一些的主题，更多精力放在写作和技术本身上面。</p><p>总之，有幸能继续在天大研习，这三年得进一步充实自己，勤学习，多更新。</p>]]></content>
    
    
    <categories>
      
      <category>Daily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读01 知识表示学习研究进展</title>
    <link href="/2022/06/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB01-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/"/>
    <url>/2022/06/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB01-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20221108130319057.png" alt="image-20221108130319057"></p><h1 id="知识表示学习研究进展论文笔记"><a href="#知识表示学习研究进展论文笔记" class="headerlink" title="知识表示学习研究进展论文笔记"></a>知识表示学习研究进展论文笔记</h1><h2 id="1-知识库"><a href="#1-知识库" class="headerlink" title="1.知识库"></a>1.知识库</h2><p>现实世界中，知识是蕴藏在无（半）结构的信息中的，比如：</p><blockquote><p>人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。</p></blockquote><p>这句话中蕴含着人工智能这一学科的基本定义，但这些知识是非结构化的，其中一条可以提取为：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/8bae01647c2ab1b9.png" alt="image-20220614181603499"></p><p>从现实世界中的无（半）结构的信息中提取结构化的知识，就是知识库的任务。知识库将知识表示为**实体(entity)<strong>间的</strong>关系(relation)**，将人类知识经过系统组织后形成结构化知识系统。作为人类知识的结晶，知识库是推动人工智能和信息服务发展的重要基础技术。</p><p>不难看出，知识表示是知识获取与应用的基础，因此，知识表示学习问题是贯穿知识库构建于应用全过程的关键问题。</p><p>知识库通用表示方式为<strong>三元组</strong>，即（实体1，关系，实体2）的形式，对应两个有某种关联的实体。实体可以是人名、地名、机构名、概念等，关系可以是包含、等价等关系。</p><p>但这种网络形式的知识表示面临两大问题：</p><ol><li>计算效率问题：这种表示方法在计算语义及推理关系时需要设计专门的图算法，有较高复杂度和较差的可拓展性，知识库较大时计算效率低，难以满足实时计算需求。</li><li>数据稀疏问题：由于知识库遵循长尾效应，在长尾部分存在严重的数据系数问题，且只有极少知识或路径涉及它们，对这些实体的语义或推理关系计算准确率极低。</li></ol><h2 id="2-表示学习"><a href="#2-表示学习" class="headerlink" title="2.表示学习"></a>2.表示学习</h2><p>为了解决上述问题，可以使用基于深度学习的表示学习技术，将研究对象的语义信息转化为稠密的低维向量，用向量之间相对位置的远近来表示语义相似度，这样就可以高效的计算实体间语义关系，有效解决数据稀疏问题。</p><p>知识库中的 实体$e$ 和 关系$r$ 可以通过表示学习得到对应向量 $l_e$ 和 $l_r$，之后可以通过计算欧氏距离或余弦距离的方式计算语义相似度。</p><p>此前常用的独热表示的方法构建词袋模型，独热向量之间相互正交，无法计算欧氏距离或余弦距离，丢失大量语义信息。且独热表示存在严重的数据稀疏问题，特别是在语言表示中。而表示学习向量维度较低，有利于<strong>提高计算效率，缓解数据稀疏问题</strong></p><p>表示学习是分布式的，即孤立地看向量中的一维没有明确意义，要综合各维度才能表示对象的语义信息。这一点与人脑神经元的原理相似，这里不做过多展开。表示学习也是层次结构的，这与物质的组成结构原理相似，即大的物体一般由更小的单位组成（多个维度组成表示某含义的向量）。</p><p>在构建知识图谱时，往往需要不断补充实体间关系，利用表示学习方法，可以预测两实体之间的关系，即<strong>知识图谱补全(Knowledge graph completion)</strong></p><p>此外，由于现实生活中同一知识体系可能在不同知识库中被记录，但在不同知识库中存在不同的表示方式，难以使用传统方法融合，如果能使用表示学习方法，将多个知识库中的知识用同一方法表示出来，就能更高效的进行多知识库的有机融合，实现异质信息融合。</p><h2 id="3-表示学习主要方法"><a href="#3-表示学习主要方法" class="headerlink" title="3.表示学习主要方法"></a>3.表示学习主要方法</h2><p>将知识库表示为 $G&#x3D;(E,R,S)$，其中 $E &#x3D; {e_1,e_2,…,e_{|E|}}$ 表示实体集合，包含 $|E|$ 种不同实体，$R &#x3D; {r_1,r_2,…,r_{|R|}}$ 是关系集合，包含 $|R|$ 种不同关系，$S \in E \times R \times E$ 表示三元组集合，单个三元组表示为 $(h,r,t)$，即头实体，关系，尾实体，如（史蒂夫·乔布斯，创始人，苹果公司）</p><h3 id="3-1-距离模型-Structured-Embedding-SE"><a href="#3-1-距离模型-Structured-Embedding-SE" class="headerlink" title="3.1 距离模型(Structured Embedding, SE)"></a>3.1 距离模型(Structured Embedding, SE)</h3><p>每个实体用 $d$ 维的向量表示，所有实体投影到同一个 $d$ 维的向量空间中。</p><p>每个关系 $r$ 都有两个矩阵 $M_{r,1}, M_{r,2} \in R^{d \times d}$，分别用于头实体和尾实体的投影操作。</p><p>损失函数为：<br>$$<br>f_r(h,t)&#x3D;|M_{r,1}l_h - M_{r,2}l_t|<br>$$<br>可以看出，损失函数使用关系矩阵将实体投影到同一空间，之后计算距离，从而反映在r下的语义相关度，距离越小则越存在这一关系。</p><p>SE将知识库中的三元组作为学习样例，以实体向量和关系矩阵为参数，不断优化，从而实现知识表示。</p><p>缺点：使用两个不同矩阵对头尾投影，协同性差。</p><h3 id="3-2-单层神经网络模型-Single-Layer-Model-SLM"><a href="#3-2-单层神经网络模型-Single-Layer-Model-SLM" class="headerlink" title="3.2 单层神经网络模型(Single Layer Model, SLM)"></a>3.2 单层神经网络模型(Single Layer Model, SLM)</h3><p>SLM 使用单层神经网络改进 SE，对每个三元组定义评分函数：<br>$$<br>f_r(h,t) &#x3D; u^T_r g(M_{r,1}l_h + M_{r,2}l_t)<br>$$<br>其中 $u^T_r$ 为关系的表示向量。</p><p>SLM 使用 $g()$ 这一 $tanh$ 双曲正切函数的非线性操作来视图寻找实体与关系间的联系。</p><p>缺点：SLM的非线性操作仅提供微弱联系，却带来较高计算复杂度。</p><h3 id="3-3-能量模型-Semantic-Matching-Energy-SME"><a href="#3-3-能量模型-Semantic-Matching-Energy-SME" class="headerlink" title="3.3 能量模型(Semantic Matching Energy, SME)"></a>3.3 能量模型(Semantic Matching Energy, SME)</h3><p>语义匹配能量模型将每个实体和关系使用低维向量表示，同时定义投影矩阵用于刻画实体与关系间的内在联系，即定义两个评分函数：<br>$$<br>f_r(h,t)&#x3D;(M_1l_h + M_2l_r + b_1)^T(M_3l_t + M_4l_r + b_2)<br>$$</p><p>$$<br>f_r(h,t)&#x3D;(M_1l_h \otimes M_2l_r + b_1)^T(M_3l_t \otimes M_4l_r + b_2)<br>$$</p><p>使用了四个投影矩阵，分别使用线性相加形式和哈达玛积的形式，再增加偏置向量，从而提高模型复杂度。</p><h3 id="3-4-双线性模型-LFM、DistMult"><a href="#3-4-双线性模型-LFM、DistMult" class="headerlink" title="3.4 双线性模型(LFM、DistMult)"></a>3.4 双线性模型(LFM、DistMult)</h3><p>隐变量模型（Latent factor model，LFM）使用基于关系的双线性变化来刻画实体与关系之间的联系。评分函数为<br>$$<br>f_r(h,t)&#x3D;l^T_hM_rl_t<br>$$<br>其中 $M_r$ 为 $r$ 对应的双线性变换矩阵（连续空间和离散空间之间转化的一种映射方法），相较于以往模型，LFM 使用简单有效的方法刻画出实体和关系间的语义联系，计算复杂度低。</p><p>DistMult 模型将 LFM 的 $M_r$ 设为对角阵，进一步简化计算的同时，模型效果得到显著提升。</p><h3 id="3-5-张量神经网络模型（Neural-Tensor-Network）"><a href="#3-5-张量神经网络模型（Neural-Tensor-Network）" class="headerlink" title="3.5 张量神经网络模型（Neural Tensor Network）"></a>3.5 张量神经网络模型（Neural Tensor Network）</h3><p>用双线性张量取代传统神经网络中的线性变换层，在不同维度下降头尾实体向量连接起来。</p><p>NTN 为每个三元组定义的评分函数如下：<br>$$<br>f_r(h,t) &#x3D; u^T_r g(l_hM_Rl_t + M_{r,1}l_h+M_{r,2}l_t+b_r)<br>$$<br>这一评分函数计算两个实体间存在关系 $r$ 的可能性。其中 $u^T_r$ 是与关系相关的线性层，$g()$ 为 $tanh$ 函数，$M_r$为三阶张量，$M_{r,1},M_{r,2}$为投影矩阵。可以看出 SLM 即为 NTN 的张量层数为0时的简化版本。</p><p>此外，NTN 中的实体向量为实体中所有单词向量的均值，由于实体单词数量远小于实体数量，可以重复利用单词向量构建实体表示，降低稀疏性问题，同时增强不同实体间的语义联系。</p><p>NTN引入张量操作，能更精准地刻画实体与关系之间的复杂联系，但计算复杂度非常高，需要大量训练数据。且实验表明，NTN在大规模稀疏知识图谱上效果较差。</p><h3 id="3-6-矩阵分解模型"><a href="#3-6-矩阵分解模型" class="headerlink" title="3.6 矩阵分解模型"></a>3.6 矩阵分解模型</h3><p>RESACL 模型将知识库的三元组构成一个大的张量 $X$，如果三元组 (h, r, t) 存在，则 $X_{hrt} &#x3D; 1$，否则为0，之后通过张量分解的方式，将三元组对应张量值 $X_{hrt}$ 分解为实体和关系表示，使 $X_{hrt}$ 尽可能接近 $l_hM_rl_t$</p><p>实际上，RESACL 与前面的 LFM 相似，但 RESACL 也会优化值为0的位置，而 LFM 只优化存在的三元组。</p><h3 id="3-7-翻译模型"><a href="#3-7-翻译模型" class="headerlink" title="3.7 翻译模型"></a>3.7 翻译模型</h3><p>受 word2vec 等模型展现的平移不变现象（词向量能够捕捉形如 king 和 queen、man 和 woman 之间的隐含语义关系）启发，TransE 模型被提出。</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/cefc1b9132b5b42b.png" alt="image-20220617083253939"></p><p>TransE 将知识库中关系看做平移向量，对每个三元组 (h, r, t)，使用关系 r 的向量 $l_r$ 作为头实体向量和尾实体相连之间的平移，也可看作从头实体到尾实体的翻译，因此 TransE 也被称作翻译模型。</p><p>TransE 希望，对于每个三元组，有：<br>$$<br>l_h + l_r \approx l_t<br>$$<br>因此，TransE 定义如下损失函数：<br>$$<br>f_r(h,t)&#x3D;|l_h + l_r - l_t|_{L_1&#x2F;L_2}<br>$$<br>即计算向量 $l_h + l_r$ 和 向量 $l_t$ 的 $L_1$ 或 $L_2$ 距离。</p><p>相较于以往的模型，TransE 使用较少的参数，以较低的计算复杂度构建出实体与关系间的复杂联系，性能提升显著，且在大规模稀疏矩阵上表现惊人。</p><p>TransE 也面临一些问题：</p><ol><li>由于 TransE 结构简单，难以除杂知识库中形如 N-N 的多对多复杂关系。相关解决方案有 TransH、TransR、TransD、TransSparse、TransA、TransG、KG2E 等模型。</li><li>TransE 没有有效利用实体和关系的描述信息、类别信息，也不能处理互联网文本等非结构化信息，难以实现多元信息融合。代表工作包括 DKRL 模型等.</li><li>TransE 孤立地学习每个三元组，不能很好地发现关系路径。代表工作包括 PTransE 等。</li></ol><h2 id="前景展望"><a href="#前景展望" class="headerlink" title="前景展望"></a>前景展望</h2><ol><li>不同知识类型的知识表示学习（树形、网格、一维、有向等类型的知识）</li><li>多元信息融合的知识表示学习（非结构化知识、多知识库知识、知识库其他信息）</li><li>复杂推理模式的知识表示学习（利用关系路径、三元组间复杂关系）</li></ol>]]></content>
    
    
    <categories>
      
      <category>PaperReading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
      <tag>DeepLearning</tag>
      
      <tag>Self-Supervised-Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习00 PyTorch环境配置</title>
    <link href="/2022/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A000-PyTorch%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A000-PyTorch%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="PyTorch-环境配置："><a href="#PyTorch-环境配置：" class="headerlink" title="PyTorch 环境配置："></a>PyTorch 环境配置：</h1><p>毕设需要用到 PyTorch，网上的教程比较老了，版本都很旧，PyTorch 已经不支持 10.2 的 cuda 了，这里重新记录一下配置过程。</p><h2 id="1-Anaconda-安装："><a href="#1-Anaconda-安装：" class="headerlink" title="1. Anaconda 安装："></a>1. Anaconda 安装：</h2><p>在 <a href="https://www.anaconda.com/">Anaconda  官网</a> 下载 Anaconda 安装包，按引导安装（选择All Users，不配置环境变量）</p><p>环境变量配置如下：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220412123333832.png" alt="image-20220412123333832"></p><p>cmd 中输入 conda –version，出现如下结果表示成功</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220412123431028.png" alt="image-20220412123431028"></p><h2 id="2-CUDA-toolkit-安装："><a href="#2-CUDA-toolkit-安装：" class="headerlink" title="2. CUDA toolkit 安装："></a>2. CUDA toolkit 安装：</h2><p>首先安装 Visual Studio 2017（千万不要装2019，如果已经安装了2019，建议卸载重新安装），至少选择 C++ 桌面开发：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220411232126734.png" alt="image-20220411232126734"></p><p>接下来安装 CUDA，为配合 PyTorch 建议使用 11.3 版本（10系以上N卡应该都支持）： </p><p><a href="https://developer.nvidia.cn/cuda-11.3.0-download-archive?target_os=Windows&target_arch=x86_64&target_version=10">安装地址</a>，选择系统及版本，建议使用本地 exe 安装：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220411230456273.png" alt="image-20220411230456273"></p><p>安装时仅选择 CUDA 组件即可：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220411230856055.png" alt="image-20220411230856055"></p><p>完成后在终端中输入 “ nvcc -V ”检测，如图则安装完毕</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220411231948925.png" alt="image-20220411231948925"></p><p>除此之外，还需安装 cuDNN，与 11.3 版本 CUDA 相匹配的版本为 8.2.1 <a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/8.2.1.32/11.3_06072021/cudnn-11.3-windows-x64-v8.2.1.32.zip">下载地址</a></p><p>下载完成后解压，复制到CUDA安装目录下</p><h2 id="3-PyTorch-配置："><a href="#3-PyTorch-配置：" class="headerlink" title="3. PyTorch 配置："></a>3. PyTorch 配置：</h2><p>首先创建新虚拟环境，cmd 中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda create -n PyTorch python=3.7<br></code></pre></td></tr></table></figure><p>出现提示后，输入 y 确定即安装完毕（网络问题可以换清华源解决）</p><p>创建完成后输入如下代码，激活虚拟环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda activate PyTorch<br></code></pre></td></tr></table></figure><p>在 <a href="https://pytorch.org/get-started/locally/">PyTorch 官网</a> 中选择好 PyTorch 版本、系统、包管理器、语言、CUDA版本：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220411224428741.png" alt="image-20220411224428741"></p><p>获得如下 Conda 命令，输入 cmd 进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch<br></code></pre></td></tr></table></figure><p>出现提示后，输入 y 确定即安装完毕</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>输入如下代码测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-built_in">print</span>(torch.cuda.is_available())<br>device = torch.device(<span class="hljs-string">&quot;cuda:0&quot;</span>)<br><br><span class="hljs-built_in">print</span>(device)<br><span class="hljs-built_in">print</span>(torch.cuda.get_device_name(<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(torch.rand(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>).cuda())<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220412170940291.png" alt="image-20220412170940291"></p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
      <tag>PyTorch</tag>
      
      <tag>Configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
