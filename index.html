<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>TakuZen&#39;s Blog | Code is Poetry</title>

  
  <meta name="author" content="ZhuoRan-TakuZen">
  

  
  <meta name="description" content="A personal Blog about Machine Learning.">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="TakuZen&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="TakuZen&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">TakuZen&#39;s Blog</a>
    </h1>
    <p class="site-description">Code is Poetry</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/31/数据管理01-Neo4j学习/"><span>数据管理01 Neo4j学习</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/31/数据管理01-Neo4j学习/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-31T06:28:27.422Z">
          2022-08-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Neo4j-学习笔记"><a href="#Neo4j-学习笔记" class="headerlink" title="Neo4j 学习笔记"></a>Neo4j 学习笔记</h1><p>图数据库是基于图论实现的一种 NoSQL 数据库，其数据存储结构和数据查询方式都以图论为基础，主要用于存储更多的连接数据。</p>
<p>在关系复杂的数据上，图数据库相比关系型数据库有着更快的查询速度，即使是对于深度和复杂的查询也是如此。</p>
<p>在图数据库中，用<strong>节点</strong>和<strong>关系</strong>来取代关系型数据库中的<strong>表</strong>和<strong>外键</strong>。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Note/">Note</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/DB/">DB</a><a href="/tags/Neo4j/">Neo4j</a><a href="/tags/Cypher/">Cypher</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2022/08/31/数据管理01-Neo4j学习/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/31/论文阅读02-知识图谱构建技术综述/"><span>论文阅读02 知识图谱构建技术综述</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/31/论文阅读02-知识图谱构建技术综述/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-31T05:00:00.000Z">
          2022-08-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220829130310059.png" alt="image-20220829130310059"></p>
<p>​        </p>
<p>​        本周阅读的是《知识图谱构建技术综述》这篇论文，于 2016 年发表于《计算机研究与发展》，是课题组知识图谱研究方向的必读论文之一。本篇综述从技术框架和图谱定义出发，介绍了知识图谱的各类构建技术及其发展历程。以下是重点概念的笔记：</p>
<h2 id="1-知识图谱定义与架构"><a href="#1-知识图谱定义与架构" class="headerlink" title="1.知识图谱定义与架构"></a>1.知识图谱定义与架构</h2><p><strong>定义：</strong>结构化语义知识库，以<strong>符号形式</strong>描述物理世界中的<strong>概念</strong>及其<strong>相互关系</strong>。</p>
<p><strong>基本组成单位：</strong>“实体-关系-实体”三元组，“实体-属性”值对。</p>
<p><strong>研究价值：</strong>能够<strong>在 Web 网页之上</strong>建立概念间的链接关系，从而<strong>以最小代价</strong>将互联网累计的知识组织起来，成为<strong>真正可用的知识</strong>。</p>
<p><strong>应用价值：</strong>改变现有的“字符串模糊匹配”信息检索方式，通过推理<strong>实现真正的概念检索</strong>，并以图形化方式向用户<strong>展示经过分类整理的结构化知识</strong>。</p>
<p><strong>逻辑架构：</strong>包括将知识以事实为单位存储在图数据库的<strong>数据层</strong>，该层以“实体-关系-实体”三元组为事实的基本表达方式，大量数据构成实体关系网络，形成“图谱”；还包括存储经提炼之后的知识的<strong>模式层</strong>，该层为知识图谱的核心，往往采用本体库来管理该层。</p>
<p><strong>技术架构：</strong>知识图谱的构建是不断更新迭代的过程。每轮迭代包括三个阶段：<strong>信息抽取</strong>、<strong>知识融合</strong>、<strong>知识加工</strong>。即可以借助百科网站等结构化数据源以<strong>自顶向下</strong>的方式构建，也可以从公开数据中提取资源模式，选择置信度高的新模式，以<strong>自底向上</strong>的方式构建。</p>
<h2 id="2-知识图谱构建技术"><a href="#2-知识图谱构建技术" class="headerlink" title="2.知识图谱构建技术"></a>2.知识图谱构建技术</h2><h3 id="2-1-信息抽取"><a href="#2-1-信息抽取" class="headerlink" title="2.1.信息抽取"></a>2.1.信息抽取</h3><p>关键问题是<strong>如何从异构数据源中自动抽取信息得到候选知识单元</strong>。具体涉及到的关键技术包括：实体抽取、关系抽取 、属性抽取。</p>
<h4 id="2-1-1-实体抽取："><a href="#2-1-1-实体抽取：" class="headerlink" title="2.1.1,实体抽取："></a>2.1.1,实体抽取：</h4><p>也叫命名实体识别（named entity recognition，NER），从文本数据集中自动识别出命名实体，由于实体抽取的质量对后续的知识获取效率及质量影响极大，因此是信息抽取中<strong>最为基础和关键的部分</strong>。</p>
<p>早起使用<strong>基于规则的方法</strong>，但有明显局限性，且耗费巨大人力；</p>
<p>随后开始使用<strong>统计机器学习的方法</strong>辅助解决命名实体抽取问题；最近也开始采用<strong>有监督学习与规则结合</strong>的方法；</p>
<p>现今，学术界开始关注开放域的信息抽取问题，不在限定于特定知识领域，而面向开放的互联网。<strong>建立科学完整的命名实体分类体系</strong>也成为了了重要问题。</p>
<h4 id="2-1-2-关系抽取："><a href="#2-1-2-关系抽取：" class="headerlink" title="2.1.2.关系抽取："></a>2.1.2.关系抽取：</h4><p>经过实体抽取后只能得到离散的命名实体，还需要通过关系抽取提取实体之间的关联关系，才能形成网状知识结构。</p>
<p>早起采用人工构造语法语义规则，模式匹配的方式，有较大的局限性，对规则制定者有较高专业要求，工作量较大；</p>
<p>之后开始使用统计机器学习方法，且近年来逐渐转向半监督和无监督的学习方式；</p>
<p>此外，还有无需预先定义实体关系类型的面向开放域的关系抽取技术，这方面的研究重点是<strong>如何提升关系抽取的准确率和召回率</strong>，以及<strong>对隐含语义关系而非词汇关系的抽取</strong></p>
<h4 id="2-1-3-属性抽取："><a href="#2-1-3-属性抽取：" class="headerlink" title="2.1.3.属性抽取："></a>2.1.3.属性抽取：</h4><p>属性抽取的目标是<strong>从不同信息源中采集特定实体的属性信息</strong>，也可以将属性抽取问题转化为名字性的关系抽取问题</p>
<p>当前主要以百科类网站提供的半结构化数据为实体属性抽取研究的数据来源；</p>
<p><strong>如何从海量的非结构化数据中抽取实体属性</strong>是值得关注的理论研究问题：一种思路是基于百科类半结构化数据训练出模型，再应用于非结构化数据；另一种思路是基于数据挖掘直接获取实体与属性之间的关系模式。</p>
<h3 id="2-2-知识融合"><a href="#2-2-知识融合" class="headerlink" title="2.2.知识融合"></a>2.2.知识融合</h3><p>主要包括知识链接和知识合并，经过知识融合可以消除歧义，剔除冗余和错误概念，从而提升知识质量。</p>
<h4 id="2-2-1-实体链接："><a href="#2-2-1-实体链接：" class="headerlink" title="2.2.1.实体链接："></a>2.2.1.实体链接：</h4><p>实体链接（entity linking）对于从文本中抽取得到的实体对象，将其链接到知识库中对应的正确实体对象的操作。</p>
<p>基本思路是：对于给定实体，从知识库中筛选出一组候选对象，再计算相似度，从而链接到正确实体对象。</p>
<p>基本流程是：从文本中抽取实体，进行实体消歧，和共指消解，连接到对应实体</p>
<h5 id="2-2-1-1-实体消歧："><a href="#2-2-1-1-实体消歧：" class="headerlink" title="2.2.1.1.实体消歧："></a>2.2.1.1.实体消歧：</h5><p>实体消歧（entity disambiguation）专门用于解决同名实体产生歧义的技术，用于解决<strong>某个实体对应于多个实体对象的问题</strong>（例：李娜可以指向歌手李娜也可以指向网球运动员李娜）。</p>
<p>聚类法消歧可以将所有指向同一实体对象的指称项聚集到该对象的中心类别之下，常用的方法有：空间向量模型（词袋模型）、语义模型、社会网络模型、百科知识模型等</p>
<h5 id="2-2-1-2-共指消解："><a href="#2-2-1-2-共指消解：" class="headerlink" title="2.2.1.2.共指消解："></a>2.2.1.2.共指消解：</h5><p>共指消解（entity resolution）用于解决<strong>多个指称项对应于同一实体对象的问题</strong>（例：在同一篇新闻中，”Barack Obama” 和 “president Obama” 以及 “the president” 等指称项可能指向的是同一个实体对象）</p>
<h4 id="2-2-2-知识合并："><a href="#2-2-2-知识合并：" class="headerlink" title="2.2.2.知识合并："></a>2.2.2.知识合并：</h4><p><strong>合并外部数据库：</strong>数据层融合需要解决实例与关系之间的冲突问题以及冗余问题；模式层融合可将新得到的本体融入已有本体库中。</p>
<p>基本流程为：获取知识、概念匹配、实体匹配、知识评估。</p>
<p><strong>合并关系型数据库：</strong>将关系型数据库的数据转换为 RDF 三元组数据，该类技术也可应用于其他半结构化数据。</p>
<h3 id="2-3-知识加工"><a href="#2-3-知识加工" class="headerlink" title="2.3.知识加工"></a>2.3.知识加工</h3><p>主要包括：本体构建、知识推理和质量评估。</p>
<h4 id="2-3-1-本体构建："><a href="#2-3-1-本体构建：" class="headerlink" title="2.3.1.本体构建："></a>2.3.1.本体构建：</h4><p>本体是对概念进行建模的规范，是描述客观世界的抽象模型。</p>
<p>本体反映的知识是一种明确定义的公式，是共享的；本体是树状结构的，相邻层次之间有严格的 “Is A” 关系</p>
<h4 id="2-3-2-知识推理："><a href="#2-3-2-知识推理：" class="headerlink" title="2.3.2.知识推理："></a>2.3.2.知识推理：</h4><p>知识推理是指从已有实体关系数据出发，经计算机推理得到实体间的新管理，从而拓展和丰富知识网络的过程。</p>
<p>推理方法可以分为：基于逻辑的推理（一阶谓词逻辑、描述逻辑、基于规则的逻辑）和基于图的推理（神经网络模型、Path Ranking 算法）。</p>
<h4 id="2-3-3-质量评估："><a href="#2-3-3-质量评估：" class="headerlink" title="2.3.3.质量评估："></a>2.3.3.质量评估：</h4><p>质量评估是知识库扣减技术的重要组成部分，引入质量评估可以对知识的可信度进行量化，并通过舍弃置信度较低的知识来保障并提升知识库质量。</p>
<h3 id="2-4-知识更新"><a href="#2-4-知识更新" class="headerlink" title="2.4.知识更新"></a>2.4.知识更新</h3><p>知识图谱的构建是不断更新迭代的过程，有两种方式：</p>
<p>全面更新：以更新后的全部数据为输入，从零开始重新构建；特点是操作简单，资源消耗大，维护开销大；</p>
<p>增量更新，以当前新增数据作为输入，向现有图谱中新增；特点是操作复杂，资源消耗小，干预开销大。</p>
<h2 id="3-跨语言知识图谱构建"><a href="#3-跨语言知识图谱构建" class="headerlink" title="3.跨语言知识图谱构建"></a>3.跨语言知识图谱构建</h2><p><strong>意义：</strong></p>
<ol>
<li>各语种知识分布不均匀，跨语言构建知识图谱可以弥补单语种知识库的不足；</li>
<li>可以充分利用多语种在知识表达方式上的互补性，从而增加知识覆盖率和共享度；</li>
<li>通过不同语言对同一知识的表述实现错误信息过滤。</li>
</ol>
<h2 id="4-知识图谱应用"><a href="#4-知识图谱应用" class="headerlink" title="4.知识图谱应用"></a>4.知识图谱应用</h2><ol>
<li><p>智能语义搜索应用：对搜索关键字进行解析和推理，映射到图谱中的概念上，再返回图形化的知识结构（如百度、谷歌搜索得到的知识卡片）；</p>
<img src="C:\Users\19658\AppData\Roaming\Typora\typora-user-images\image-20220830223809812.png" alt="image-20220830223809812" style="zoom:50%;" />
</li>
<li><p>深度问答应用：对问题进行语义分析和语法分析，转化为结构化的查询语句，再在图谱中查询答案（对与知识库中没有答案的情况，采用知识推理技术给出）；</p>
</li>
</ol>
<h2 id="5-问题与挑战"><a href="#5-问题与挑战" class="headerlink" title="5.问题与挑战"></a>5.问题与挑战</h2><ol>
<li>面向开放域的信息抽取方法仍处于起步阶段；</li>
<li>知识融合环节中，如何实现准确的实体链接；</li>
<li>知识加工过程中的推理技术亟待突破；</li>
<li>知识更新环节严重依赖人工干预；</li>
<li>如何解决知识的表达、存储与查询问题。</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/PaperReading/">PaperReading</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/KnowledgeGraph/">KnowledgeGraph</a><a href="/tags/Summarize/">Summarize</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2022/08/31/论文阅读02-知识图谱构建技术综述/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/15/数据管理00-openGauss-Docker部署/"><span>数据管理00 openGauss Docker部署</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/15/数据管理00-openGauss-Docker部署/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-15T05:33:41.618Z">
          2022-08-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="openGauss-架构学习"><a href="#openGauss-架构学习" class="headerlink" title="openGauss 架构学习"></a>openGauss 架构学习</h1><p>openGauss 是华为研发的开源关系型数据库，具有高性能、高可用、高安全、易运维、全开放特点。</p>
<h3 id="openGauss-系统架构："><a href="#openGauss-系统架构：" class="headerlink" title="openGauss 系统架构："></a>openGauss 系统架构：</h3><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220815141035566.png" alt="image-20220815141035566" style="zoom:50%;" />

<p>OM（Operation Manager）：运维管理模块，提供集群日常运维、配置管理的接口和工具，包括安装、升级以及系统层面的一些功能。</p>
<p>CM（Cluster Manager）：集群管理模块，提供集群启停、主备切换、状态查询等功能。</p>
<p>openGauss 主备（Data Node)：在企业部署中，往往采用主备的形式，主机备机通常部署在不同的物理节点上。社区版 openGauss 支持最多 7 个备份。</p>
<p>客户端驱动（Client Driver）：面向用户，接受访问请求，返回查询结果。提供 SQL 查询、JDBC、ODBC等功能。</p>
<p>Storage：支持本地存储、云存储等不同形式介质的访问。</p>
<p>openGauss 内核：提供内存管理、进程管理、SQL引擎等核心功能。</p>
<h3 id="openGauss-内核架构："><a href="#openGauss-内核架构：" class="headerlink" title="openGauss 内核架构："></a>openGauss 内核架构：</h3><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220815142021363.png" alt="image-20220815142021363" style="zoom:50%;" />

<p>用户在业务侧通过 GSQL、JDBC、Python 等客户端驱动连接到数据库，由业务处理线程进行处理；经过词法&#x2F;语法分析，进行语义处理；再在 SQL 优化器中对语句进行优化改写，生成执行计划，下发到执行引擎中；执行时，对象等信息存储在数据字典缓冲区，磁盘数据存储在数据缓冲区，方便下次查询，日志缓冲区用于暂存日志。</p>
<p>除了业务处理线程外，还有系统监控、检查点、后台写、日志写、归档等多个后台线程，提供其他各类行动，这些线程协作运行，构建出 openGauss 的内核体系架构。</p>
<h3 id="openGauss-线程管理："><a href="#openGauss-线程管理：" class="headerlink" title="openGauss 线程管理："></a>openGauss 线程管理：</h3><p><strong>采用多线程的原因：</strong></p>
<ul>
<li>多进程应用的不同进程之间数据共享复杂，同步简单；多线程应用数据共享简单，同步复杂</li>
<li>多进程应用占用内存多、切换复杂、速度慢、CPU 利用率低下；多线程应用占用内存少、切换简单、CPU 利用率高</li>
</ul>
<p>尽管有更大的开发和维护难度，线程管理模式能为 openGauss 提供更极致的性能，减少频繁创建或切换进程带来的开销，更高效的利用资源。</p>
<p><strong>线程分类：</strong></p>
<img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220816150647613.png" alt="image-20220816150647613" style="zoom:50%;" />

<p>主线程 - PostmasterMain：初始化、启动辅助线程、循环监听</p>
<p>业务处理线程 - PostgresMain：处理客户端连接请求、执行相关 SQL 业务</p>
<p>辅助线程：日志读写、读脏、检查点、统计信息等等</p>
<h1 id="容器安装"><a href="#容器安装" class="headerlink" title="容器安装"></a>容器安装</h1><p>使用 Docker 安装 openGauss 镜像，省去搭建 CentOS 虚拟机的步骤</p>
<h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>构建 CentOS 7.6 镜像，之后按顺序执行命令，构建 OpenGauss 镜像。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.6</span>.<span class="number">1810</span></span><br><span class="line"><span class="comment">#安装依赖包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum update -y &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">	yum install -y <span class="built_in">which</span> gcc gcc-c++ gdb git make cmake wget libaio-devel flex bison ncurses-devel glibc-devel patch lsb_release readline-devel</span></span><br><span class="line"><span class="comment">#创建用户，openGauss基于postgresql，和postresql一样，不能在root用户下启动</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;123456&#x27;</span> | passwd --stdin root &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    groupadd dbgroup &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    useradd -g dbgroup omm</span></span><br><span class="line"><span class="comment">#切换工作目录，下面几条命令都在此目录下执行</span></span><br><span class="line"><span class="keyword">USER</span> omm</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/omm</span></span><br><span class="line"><span class="comment">#下载openGauss-third_party_binarylibs解压</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget https://opengauss.obs.cn-south-1.myhuaweicloud.com/latest/openGauss-third_party_binarylibs.tar.gz &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    tar -zxf openGauss-third_party_binarylibs.tar.gz &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mv</span> openGauss-third_party_binarylibs binarylibs</span></span><br><span class="line"><span class="comment">#clone源码，编译，编译后安装在/home/omm/openGauss-server/mppdb_temp_install下</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git <span class="built_in">clone</span> https://gitee.com/opengauss/openGauss-server.git &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cd</span> openGauss-server &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    sh build.sh -m debug -3rd /home/omm/binarylibs &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> -r simpleInstall/ mppdb_temp_install/</span></span><br><span class="line"><span class="comment">#清理垃圾文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> openGauss-third_party_binarylibs.tar.gz</span></span><br></pre></td></tr></table></figure>

<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>PowerShell 中使用 docker 命令构建镜像</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从gite仓库访问dockerfile脚本构建镜像,指定构建好的镜像名称为：open-gauss-debug:v1</span></span><br><span class="line">docker build openGaussDockerfile <span class="literal">-t</span> <span class="built_in">open-gauss</span><span class="literal">-debug</span>:v1</span><br></pre></td></tr></table></figure>

<p>之后等待约15分钟（设备配置决定）即可构建完成</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/Snipaste_2022-08-14_20-12-10.png" alt="Snipaste_2022-08-14_20-12-10"></p>
<p>之后使用 docker images 命令查看已安装镜像，可以看到 open-gauss-debug 镜像已经存在，并使用 docker run 命令启动镜像，进入默认安装文件夹，可以看到数据库已经安装完毕</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -u 参数指定登录的用户，openGauss不能在root用户下启动</span></span><br><span class="line">docker run <span class="literal">-u</span> omm <span class="literal">-it</span> <span class="built_in">open-gauss</span><span class="literal">-debug</span>:v1</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/Snipaste_2022-08-14_20-12-45.png" alt="Snipaste_2022-08-14_20-12-45" style="zoom:150%;" />

<p>之后进入 simpleInstall 文件夹，运行安装脚本 install.sh，该脚本可配置环境变量并初始化一个用于测试的 demo 数据库</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> simpleInstall/</span><br><span class="line"><span class="comment"># -w 是指定初始化数据库的密码</span></span><br><span class="line">sh install.sh <span class="literal">-w</span> Gauss_123</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/Snipaste_2022-08-14_20-13-09.png" alt="Snipaste_2022-08-14_20-13-09"></p>
<p>脚本安装完成后会询问是否创建 demo 数据库，输入 yes，完成数据库搭建</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220815135918319.png" alt="image-20220815135918319"></p>
<p>之后还需要刷新环境变量，才能连接数据库</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#让bash重新加载.bashrc文件</span></span><br><span class="line">source ~/.bashrc</span><br><span class="line"><span class="comment">#连接数据库</span></span><br><span class="line">gsql <span class="literal">-d</span> postgres</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220815140100463.png" alt="image-20220815140100463"></p>
<p>使用 \l 命令测试，出现查询结果，即安装完成</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220815140219461.png" alt="image-20220815140219461"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Note/">Note</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/openGauss/">openGauss</a><a href="/tags/DB/">DB</a><a href="/tags/Docker/">Docker</a><a href="/tags/Configuration/">Configuration</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2022/08/15/数据管理00-openGauss-Docker部署/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/06/机器学习05-Transformer/"><span>机器学习05 Transformer</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/06/机器学习05-Transformer/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-06T05:30:00.000Z">
          2022-08-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><h2 id="Transformer-是什么？"><a href="#Transformer-是什么？" class="headerlink" title="Transformer 是什么？"></a>Transformer 是什么？</h2><p>本质上是一种 Sequence to sequence (Seq2seq) 的转换</p>
<p>输入是序列，输出也是序列（输出长度不确定）</p>
<p>适合用于语音识别（现在多使用 RNN-Transducer）、文本翻译、QA、NLP（转化为QA）等（输出序列长度不确定，没有明确关系）</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414014551597.png" alt="image-20220414014551597"></p>
<p>也可用于 Multi-label Classification 多标签分类</p>
<p>输入符合输出结果中的多种标签，是一对多的分类问题，比如输入是一篇文章，输出既有语言，又有体裁，又有正负面评价等等标签。</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414020620729.png" alt="image-20220414020620729"></p>
<p>Multi-class Classification 多类别分类（传统分类问题，与前者区分）</p>
<p>输入属于输出结果中的某一个类，是一对一的分类问题，比如输入是一段语音，输出分类为中文或英文（看似与多标签分类问题相似，实际两者很难用同一类模型解决）</p>
<h2 id="Seq2seq-基本结构"><a href="#Seq2seq-基本结构" class="headerlink" title="Seq2seq 基本结构"></a>Seq2seq 基本结构</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414021014715.png" alt="image-20220414021014715"></p>
<p>基本结构：输入序列经过 **编码器 Encoder **部分处理，交由 **解码器 Decoder **处理为输出序列</p>
<h3 id="Encoder-编码器"><a href="#Encoder-编码器" class="headerlink" title="Encoder 编码器"></a>Encoder 编码器</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414021341139.png" alt="image-20220414021341139"></p>
<p>Encoder 的任务是将一个向量输入转化为另一个向量输出，可以使用 RNN、CNN 等各种模型。</p>
<h3 id="Decoder-解码器"><a href="#Decoder-解码器" class="headerlink" title="Decoder 解码器"></a>Decoder 解码器</h3><h4 id="Autoregressive-Decoder-自回归解码器"><a href="#Autoregressive-Decoder-自回归解码器" class="headerlink" title="Autoregressive Decoder 自回归解码器"></a>Autoregressive Decoder 自回归解码器</h4><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414023057892.png" alt="image-20220414023057892"></p>
<p>以语音识别为例，Decoder 将 Encoder 的输出作为输入，在得到开始信号（BEGIN）之后，计算得到第一个输出结果，并将这一结果连同 Encoder 输出作为新的输入，计算得到下一个输出结果，如此反复直到输出结束</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414023356616.png" alt="image-20220414023356616"></p>
<p>事实上，编解码器结构是比较相似的。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Note/">Note</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/DeepLearning/">DeepLearning</a><a href="/tags/Transformer/">Transformer</a><a href="/tags/MachineLearning/">MachineLearning</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2022/08/06/机器学习05-Transformer/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/04/机器学习04-自监督学习/"><span>机器学习04 自监督学习</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/04/机器学习04-自监督学习/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-04T05:30:00.000Z">
          2022-08-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Self-supervised-Learning-自监督学习"><a href="#Self-supervised-Learning-自监督学习" class="headerlink" title="Self-supervised Learning 自监督学习"></a>Self-supervised Learning 自监督学习</h1><h2 id="Supervised-监督"><a href="#Supervised-监督" class="headerlink" title="Supervised 监督"></a>Supervised 监督</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414013529142.png" alt="image-20220414013529142"></p>
<p>数据集需要人工标注，让机器知道学习方向</p>
<h2 id="Self-Supervised-自监督"><a href="#Self-Supervised-自监督" class="headerlink" title="Self-Supervised 自监督"></a>Self-Supervised 自监督</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414013744717.png" alt="image-20220414013744717"></p>
<p>将数据集分为两部分，一部分作为输入，一部分用于校验输出效果（当作标注结果）</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Note/">Note</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/DeepLearning/">DeepLearning</a><a href="/tags/MachineLearning/">MachineLearning</a><a href="/tags/Self-Supervised-Learning/">Self-Supervised-Learning</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2022/08/04/机器学习04-自监督学习/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/02/机器学习03-CNN/"><span>机器学习03 CNN</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/02/机器学习03-CNN/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-02T12:08:00.000Z">
          2022-08-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Convolutional-Neural-Network（CNN）"><a href="#Convolutional-Neural-Network（CNN）" class="headerlink" title="Convolutional Neural Network（CNN）"></a>Convolutional Neural Network（CNN）</h1><p>CNN 通常用于图片识别上</p>
<h2 id="图片对计算机来说是什么？"><a href="#图片对计算机来说是什么？" class="headerlink" title="图片对计算机来说是什么？"></a>图片对计算机来说是什么？</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220430192356542.png" alt="image-20220430192356542"></p>
<p>对于计算机而言，图片是一个3维度的张量（tensor），分别是：长、宽、通道数值。 </p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Note/">Note</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/DeepLearning/">DeepLearning</a><a href="/tags/MachineLearning/">MachineLearning</a><a href="/tags/CNN/">CNN</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2022/08/02/机器学习03-CNN/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/07/30/机器学习02-常见问题/"><span>机器学习02 常见问题</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/07/30/机器学习02-常见问题/" rel="bookmark">
        <time class="entry-date published" datetime="2022-07-30T12:08:00.000Z">
          2022-07-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>当学习结果不够好的时候，通常是按照如下步骤进行 的：</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414194117158.png" alt="image-20220414194117158"></p>
<p>首先检查训练数据上的 LOSS，如果 LOSS 已经很大，那么基本上是两种情况：一种是模型偏差，一种是最优解没有找到</p>
<h2 id="模型偏差-Model-Bias"><a href="#模型偏差-Model-Bias" class="headerlink" title="模型偏差 Model Bias"></a>模型偏差 Model Bias</h2><p>模型过于简单，无论何种参数都无法获得较好的 LOSS，这是通常要改变模型设计，通过增加 Feature 、增加更多 Layer 等方法使模型更加复杂多变。</p>
<h2 id="最优解问题-Optimization-Issue"><a href="#最优解问题-Optimization-Issue" class="headerlink" title="最优解问题 Optimization Issue"></a>最优解问题 Optimization Issue</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414194526695.png" alt="image-20220414194526695"></p>
<p>仅仅获得了局部最优解，没有找到真正的最优解，可以先尝试使用简单模型（易于求解最优解的方法），或使用更深层次（如果更深层次表现反而不好，多数情况下是最优解问题）</p>
<p>在训练数据上已经获得了较好的 LOSS 之后，再查看测试数据上的 LOSS，如果测试数据上的 LOSS 已经够小，则问题已经基本解决，如果测试数据上的 LOSS 仍然较大，则可能是出现了 <strong>Overfitting 过拟合</strong> 问题</p>
<h2 id="过拟合-Overfitting"><a href="#过拟合-Overfitting" class="headerlink" title="过拟合 Overfitting"></a>过拟合 Overfitting</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414200050052.png" alt="image-20220414200050052"></p>
<p>训练得到的函数在训练数据上表现得好，但在没有训练数据的部分上“自由发挥”了，导致 LOSS 较大</p>
<p>如何解决呢？</p>
<ol>
<li>增加训练数据或创造更多数据（从已有数据生成，如图像识别问题，可以左右翻转图片）</li>
<li>限制模型，降低模型弹性（降低参数数量、神经元数量、共享参数等）</li>
<li>减少 Feature</li>
<li>Early stopping</li>
<li>Regularization</li>
<li>Dropout</li>
</ol>
<p>也可以将训练数据分为训练集和确认集，用确认集来模拟测试的过程，分解方式可以选择如下的方式：</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220414204910006.png" alt="image-20220414204910006"></p>
<p>将数据等分为多份，之后将不同的部分轮流作为确认集进行测试。</p>
<h2 id="Mismatch-误配"><a href="#Mismatch-误配" class="headerlink" title="Mismatch 误配"></a>Mismatch 误配</h2><p>除了 Overfitting 问题外，实际情况上的模型表现不好，也有可能是出现了 Mismatch 问题，由于一些其他原因导致，而非模型本身的问题。</p>
<h2 id="Saddle-Point-鞍点"><a href="#Saddle-Point-鞍点" class="headerlink" title="Saddle Point 鞍点"></a>Saddle Point 鞍点</h2><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220425121948271.png" alt="image-20220425121948271"></p>
<p>除了 Local Minima 局部最优的情况之外，还有另一种情况，loss也很难下降，这种情况下某一方向上是极小值，某一方向上又是极大值，使得其微分为0，也就是 Saddle Point 鞍点，与 Local Minima 统称为 Critical point 临界点。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Note/">Note</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/DeepLearning/">DeepLearning</a><a href="/tags/MachineLearning/">MachineLearning</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2022/07/30/机器学习02-常见问题/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/07/25/机器学习01-介绍/"><span>机器学习01 介绍</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/07/25/机器学习01-介绍/" rel="bookmark">
        <time class="entry-date published" datetime="2022-07-25T12:08:00.000Z">
          2022-07-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>台大李宏毅老师机器学习课程学习笔记，暑期重新整理：</p>
<p>近年来 AI 技术越来越热，各种 AI 技术被吹捧的神乎其神，当前的 AI 技术到底发展到了什么程度？又在朝着哪里发展？</p>
<p>事实上目前所说的“AI”与科幻小说中通人情，高智商的强人工智能还相去甚远，大部分都还只是 Machine Learning，是一种“暴力”方式解决问题的技术。</p>
<h2 id="Machine-Learning-≈-Looking-for-Function"><a href="#Machine-Learning-≈-Looking-for-Function" class="headerlink" title="Machine Learning ≈ Looking for Function"></a>Machine Learning ≈ Looking for Function</h2><p>简单来说，机器学习的实质是<strong>寻找一个难以用人力创造的函数</strong></p>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314151118633.png" alt="image-20220314151118633"></p>
<p>很多复杂问题都能概括为寻求一个函数，给定输入，以期望得到某个正确的输出。</p>
<ul>
<li>语音识别：给定音频信号，输出对应语言的文字</li>
<li>图像识别：给定图片数据，输出对应事物的名称</li>
<li>围棋AI：给定棋盘数据，得到胜率最高达的下一步坐标</li>
</ul>
<p>但这些问题通常难以解决，特别是涉及高维和低维信息之间转换的问题，难以用传统方法寻求二者之间的联系。</p>
<p>随着计算机算力水平的提升，用机器每秒上百万次的强大运算能力来“暴力破解”输入输出之间的关系也不再是空谈，这就是机器学习。</p>
<h2 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h2><p>简单来说机器学习可以分为以下三类：</p>
<p><strong>Regression（回归）</strong>：让函数得到某个数值。如 PM2.5 预测</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314151404348.png" alt="image-20220314151404348"></p>
<p><strong>Classification（分类）</strong>：给出一些选项（类别），函数输出正确的选项。如垃圾邮件分类</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314151527247.png" alt="image-20220314151527247"></p>
<p> <strong>Structured Learning（结构）</strong>：构建出具有结构的输出。如生成图像，文档</p>
<h2 id="如何获得这个函数？"><a href="#如何获得这个函数？" class="headerlink" title="如何获得这个函数？"></a>如何获得这个函数？</h2><p>函数由表达式、输入和输出组成，第一步就是写出表达式：</p>
<h3 id="1-写出带有未知参数的函数"><a href="#1-写出带有未知参数的函数" class="headerlink" title="1.写出带有未知参数的函数"></a>1.写出带有未知参数的函数</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314164944251.png" alt="image-20220314164944251"></p>
<p>其中，y是函数结果，x1是输入。</p>
<p>通常而言，我们不表达式都不是上图这种简单的线性方程，具体函数形式基于不同的问题而定，上面的例子中，习惯将w称作权重，b称作偏差。</p>
<p>如何选择合适的表达式，构建出符合问题要求的模型，是当下机器学习领域的重点之一。</p>
<p>不难看出，上述表达式中存在很多未知的参数，这些参数就是要求解部分，得到参数后，对于任意给定的输入均能得到对应输出。</p>
<p>那么参数如何计算得到呢？</p>
<p>要计算参数，可以通过对已知结果逆运算得出，这些已知的“输入”被称为特征，“输出”被称为标记，共同构成了训练数据。</p>
<p>如果有海量的训练数据，就能通过这些数据反推出合适的参数，从而得到最终的表达式。为此需要有一个衡量参数好坏的函数，在每一次使用训练数据计算参数时，对参数进行评估，从而方便下一步对参数进行调整。</p>
<h3 id="2-基于训练数据计算-Loss"><a href="#2-基于训练数据计算-Loss" class="headerlink" title="2.基于训练数据计算 Loss"></a>2.基于训练数据计算 <strong>Loss</strong></h3><p>Loss 是计算结果偏差的函数，用于衡量当前得到的未知参数的好坏。</p>
<p>在第一次计算时，我们可以随机对参数进行赋值，将输入代入表达式，得到预测结果，之后与 <strong>Label（真实数据）</strong> 计算Loss（通常是MAE、MSE等差额计算）。从而反映出本次表达式所使用的的参数的优劣程度。</p>
<p>如果将各种可能的未知参数都尝试一遍，计算出相应的 Loss，绘制出 <strong>”Error Surface“</strong>，可以观测到最合适的未知参数。</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314170218911.png" alt="image-20220314170218911"></p>
<p>但真实情况中，由于参数众多，形式复杂，很难用图像直观表达出来，只能得到不同情况下参数对应的 Loss 值。</p>
<p>在得到 Loss 后，我们就了解了目前的参数的优劣，之后就需要将参数进行调整，使计算结果更加贴近真实值，让 Loss 越来越小，也就是 Optimization（优化） 的过程。</p>
<h3 id="3-优化"><a href="#3-优化" class="headerlink" title="3.优化"></a>3.优化</h3><p>获得最佳的未知参数，可以使用 <em><strong>Gradient Descent（梯度下降）</strong></em> ，单个参数的该算法步骤如下：</p>
<p>首先，随机选取一个 w 作为初始值</p>
<p>其次，计算该 w 对应的 loss 值，并计算 L 在 w 上的微分（即斜率）</p>
<p>​        通过这一步，我们可以确定此时的 w 值是偏大还是偏小，如果斜率为正，说明 w 增加会增大 Loss，w 减少则会减少 Loss，斜率为负值则相反，</p>
<p>之后，我们需要设定一个 <strong>η（学习速率）</strong>，来划定我们每次对 w 的变化大小， 对 w 进行变化（用 η 乘上微分）后反复如上的计算，从而获得最佳的未知参数。这些由我们自己设定的参数被称为 <em><strong>Hyperparameters（超参数）</strong></em></p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314171705030.png" alt="image-20220314171705030"></p>
<p>然而，我们很容易发现，这种方法在微分值为0时就会停止，得到的参数可能只是局部最佳值，而非全局最佳值。不过尽管 Gradient Descent 存在这一问题，但在实际生产实践中可以通过取多次随机点的方式轻松解决，这一方法的真正痛点另有别处。</p>
<p>相应的，多参数方法也很容易得到：</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314172110989.png" alt="image-20220314172110989"></p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314172226936.png" alt="image-20220314172226936"></p>
<h2 id="如何改进？"><a href="#如何改进？" class="headerlink" title="如何改进？"></a>如何改进？</h2><p>经过上述的三个基本步骤，我们很容易就能计算出“最佳”的未知参数，但事实上，这种预测往往存在较大偏差，在上述例子中，我们选用的是最简单的 <strong>Liner Model（线性模型）</strong>，即使用权重和偏差值来进行预估的简单模型，这种模型考虑的因素少，性能有限，只能表现线性的单调变化。</p>
<p>实际问题中，我们往往需要更加贴合实际问题的模型，这才是机器学习的难点所在。</p>
<h3 id="Sigmoid-Function（S形函数）"><a href="#Sigmoid-Function（S形函数）" class="headerlink" title="Sigmoid Function（S形函数）"></a>Sigmoid Function（S形函数）</h3><p>由于函数变化多种多样，我们可以将函数分为多段，每一段视为一个斜率近似固定的直线，这样我们就将一条曲线分解为了多段曲线之和，每一段曲线的其他部分均为常数，只有在与其斜率吻合的部分是有斜率的，即下图的 <strong>Hard Sigmoid（硬S函数）</strong></p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314182644869.png" alt="image-20220314182644869"></p>
<p>由于分段函数表达式不便于计算，我们使用 <strong>Sigmoid Function（S形函数）</strong>来近似的表达这些曲线。</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314183750691.png" alt="image-20220314183750691"></p>
<p>其中，w 用于改变斜率，b 用于改变左右位置，c 改变高度</p>
<p>这样我们就能将曲线拆分为多个 Sigmoid Function 之和：</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314183859065.png" alt="image-20220314183859065"></p>
<p>将这一程序化过程用线性代数表示即为如下方式：<img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314184826782.png" alt="image-20220314184826782"></p>
<p>将其中的未知参数拼接为向量 θ ：</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314185208598.png" alt="image-20220314185208598"></p>
<p>此时，Loss 计算方法不变，仍然是给定一组 θ ，与真实值 label 进行对比即可：</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314195756458.png" alt="image-20220314195756458"></p>
<p>参数优化方法也仍然相似：</p>
<p>​	找出初始值（随机）；</p>
<p>​	求参数向量的微分向量（ <em>gradient</em> ）；</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314195956073.png" alt="image-20220314195956073"></p>
<p>​	更新 θ 向量：    </p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314200128627.png" alt="image-20220314200128627"></p>
<p> 重复计算和更新，直到计算结束（无法计算或重复一定次数）</p>
<h3 id="分组（Batch）优化"><a href="#分组（Batch）优化" class="headerlink" title="分组（Batch）优化"></a>分组（Batch）优化</h3><p>之前计算 Loss 时，我们将全部输入与真实值对比得到 Loss，另一种方法是，将整个数据集分为一个个 <strong>Batch</strong>，每个 Batch 大小相同，具体大小随意。</p>
<p>每次对一个组进行 Loss 计算，之后使用这个 Loss 计算 gradient，使用这个 gradient 更新参数向量 θ，再将这个新的 θ 放到 下一个组中计算 Loss，如此重复直到所有的组完成一次计算，这样就对<strong>所有数据完成了一次训练</strong>，即一次 <strong>Epoch</strong>。</p>
<p>在这一次 epoch 中，更新了相当于 batch 数量的 update 次数。</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314202247672.png" alt="image-20220314202247672"></p>
<h3 id="Rectified-Linear-Unit（ReLU函数"><a href="#Rectified-Linear-Unit（ReLU函数" class="headerlink" title="Rectified Linear Unit（ReLU函数)"></a>Rectified Linear Unit（ReLU函数)</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314202456620.png" alt="image-20220314202456620"></p>
<p>除了 S 形函数外，也可以使用上图所示的 ReLU 函数 ，两个 ReLU 函数相加就能得到一个 S 形函数表示的折线：</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314202848249.png" alt="image-20220314202848249"></p>
<p>在列出表达式时需要注意：<img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314202931594.png" alt="image-20220314202931594"></p>
<p>相较于线性模型，使用 ReLU 可以带来较为显著的提升，课程样例的结果如下：</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314203137316.png" alt="image-20220314203137316"></p>
<p>可以看到当 ReLU 数量较少时效果一般，但当 ReLU 数量较多时，更加贴合的曲线就能带来更好的预测效果。</p>
<h3 id="“套娃”"><a href="#“套娃”" class="headerlink" title="“套娃”"></a>“套娃”</h3><p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314203526849.png" alt="image-20220314203526849"></p>
<p>我们也可以使用 ReLU 等模型进行反复“套娃处理”，多进行几层，增加更多的参数，进行更相似的拟合，得到更好的预测效果：</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314203800478.png" alt="image-20220314203800478"></p>
<p>经过上述优化，我们得到的曲线如下图蓝色曲线所示，尽管已经非常贴近，但一些意外（如下图拟合失误的部分，正处于除夕，计算机无法预测到这一影响）</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314203951386.png" alt="image-20220314203951386"></p>
<h2 id="神经网络-amp-深度学习"><a href="#神经网络-amp-深度学习" class="headerlink" title="神经网络 &amp; 深度学习"></a>神经网络 &amp; 深度学习</h2><p>由于整个计算过程中有大量的 Sigmoid 或者 ReLU 这样的小单元，就好像一个个神经元一样，我们将每个 Sigmoid 或者 ReLU 称为 <strong>Neuron（神经元）</strong>，整个模型被称为 <strong>Neural Network（神经网络）</strong></p>
<p>像上文提到的<strong>“套娃”</strong>一样，有着多层嵌套结构的机器学习，就称为 <strong>Deep Learning 深度学习</strong></p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>1.既然任何曲线都可用多段的 ReLU 或 Sigmoid 拼接，为什么不使用更多的神经元来模拟，而进行这种增加层数的操作呢？</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314210841598.png" alt="image-20220314210841598"></p>
<p>2.层数越多越好吗？然而现实中，经常出现 <strong>Overfitting（过拟合）</strong>问题，即训练资料上表现好，但在预测中表现不好，那我们该采用多少层的模型呢？又如何解决 Overfitting 问题呢？</p>
<p><img src="https://raw.githubusercontent.com/Lzz1027/markdownImage/main/img/image-20220314211103505.png" alt="image-20220314211103505"></p>
<p>（事实上，大所数有更多层次的模型表现不好的问题根源在于最优解没有找到，由于梯度下降方法往往只能得到局部最优解，所以产生了更差的效果，并非过拟合的情况）</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Note/">Note</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/DeepLearning/">DeepLearning</a><a href="/tags/MachineLearning/">MachineLearning</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2022/07/25/机器学习01-介绍/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/07/24/论文阅读01-TransE/"><span>论文阅读01 TransE</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/07/24/论文阅读01-TransE/" rel="bookmark">
        <time class="entry-date published" datetime="2022-07-24T05:57:14.839Z">
          2022-07-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>前段时间忙家里各种杂事，只看了师兄给的一篇表示学习综述，大概了解了一下知识图谱和表示学习相关的技术，接下来计划将一些重要模型进一步学习，自己尝试实现一下，这里就以 TransE 作为开头，开个新坑。</p>
<h1 id="TransE-原理"><a href="#TransE-原理" class="headerlink" title="TransE 原理"></a>TransE 原理</h1><p>TransE 模型来源于 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.5555/2999792.2999923">Translating embeddings for modeling multi-relational data</a> 这篇论文，从标题上不难看出，TransE 将表示学习的过程看做是<strong>“翻译”</strong>的过程。其基本思想是，将知识三元组中的 relation 看做从 head 到 tail 的翻译过程，如果将这些关系都用向量表示，则应满足</p>
<p>$$<br>head + relation \approx tail<br>$$<br>为了让 relation 的表示能够达到以上要求，TransE 定义了一个距离函数 $d(h + r, t)$来计算头实体和为尾实体之间的距离，原论文使用的是欧氏距离，也可以使用曼哈顿距离。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c271aad4fc8f9026b19dc31246c3b50c_1440w.jpg" alt="img"></p>
<p>如果成功构建了这样规则下的网络关系，那么就可以根据一个实体和关系来预测另一个实体，或者通过两个实体直接预测它们的关系。</p>
<h1 id="TransE-训练"><a href="#TransE-训练" class="headerlink" title="TransE 训练"></a>TransE 训练</h1><p>训练时首先随机生成初始实体向量和关系向量，用于表示知识图谱。整个训练的目的就是求解正确的向量数值，损失函数可以使用 $d(h + r, t)$ 来计算，分为两个方向，正确的三元组应当有更小的 $d$，错误的三元组的 $d$ 则是越大越好。这种方法就是 <strong>negative sampling</strong>，<strong>即相对于负例，正例的得分更高</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20190504222759459.png" alt="在这里插入图片描述"></p>
<p>其中 $(h’,l,t’)$ 称为 <strong>corrupted triplet</strong>，是非同时随机替换头或尾实体得到的负例（也可以替换relation）。$\gamma$ 为 margin。事实上这就是在计算 Soft-margin Loss，可以认为，transE针对给定三元组进行二分类任务，其中负例是通过替换自行构造的，目标是使得最相近的正负例样本距离最大化。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/PaperReading/">PaperReading</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/TransE/">TransE</a><a href="/tags/RepresentationLearning/">RepresentationLearning</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2022/07/24/论文阅读01-TransE/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/07/22/重启Github博客/"><span>重启Github博客</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/07/22/重启Github博客/" rel="bookmark">
        <time class="entry-date published" datetime="2022-07-22T03:55:24.912Z">
          2022-07-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>前段时间码云大面积封禁了图床仓库，前面大概几十篇博客的图链都挂了，要逐一去修改这几百张图的链接想想都头大…</p>
<p>之前用码云还是因为国内用 Github 不是很方便，经常打不开。但考虑到之前码云对 Git page 的整改，以及最近针对图床和仓库的各种操作，还是打算换回 Github 用。</p>
<p>回头看大学这几年的博客，就是自己这四年的缩影：大一初识编程，博客里除了七零八碎的小知识就是期末复习；大二开始接触各类前后端框架，就开始满是环境配置和框架特性了；再到大三考研备考，博客不怎么写了，但甚至有一篇马原的总结；最后大四了才开始了解机器学习，又是一片新天地。</p>
<p>初期博客写作质量不够高，大多是知识的简单复述，博客主题也有点过于花里胡哨。这次换了个纯粹简约一些的主题，更多精力放在写作和技术本身上面。</p>
<p>总之，有幸能继续在天大研习，这三年得进一步充实自己，勤学习，多更新。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Daily/">Daily</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Github/">Github</a><a href="/tags/Blog/">Blog</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2022/07/22/重启Github博客/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 ZhuoRan-TakuZen
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>